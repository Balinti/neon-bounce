<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Neon Bounce - Free HTML5 Game</title>
<meta name="description" content="Play Neon Bounce - Tap to bounce a glowing ball between neon platforms. Miss a platform and fall into the void. Platforms get narrower as score increases.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0b0f1a">
<link rel="canonical" href="https://balinti.github.io/neon-bounce/">
<meta property="og:type" content="website">
<meta property="og:title" content="Neon Bounce - Free HTML5 Game">
<meta property="og:description" content="Play Neon Bounce - Tap to bounce a glowing ball between neon platforms. Miss a platform and fall into the void. Platforms get narrower as score increases.">
<meta property="og:url" content="https://balinti.github.io/neon-bounce/">
<meta property="og:image" content="https://balinti.github.io/neon-bounce/og-image.jpg">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Neon Bounce - Free HTML5 Game">
<meta name="twitter:description" content="Play Neon Bounce - Tap to bounce a glowing ball between neon platforms. Miss a platform and fall into the void. Platforms get narrower as score increases.">
<meta name="twitter:image" content="https://balinti.github.io/neon-bounce/og-image.jpg">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "Neon Bounce",
  "applicationCategory": "Game",
  "operatingSystem": "Web",
  "offers": { "@type": "Offer", "price": "0", "priceCurrency": "USD" }
}
</script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0b0f1a;font-family:'Segoe UI',system-ui,sans-serif}
#wrap{position:relative;max-width:420px;max-height:750px;margin:0 auto;width:100%;height:100vh;height:100dvh;touch-action:none;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}
canvas{display:block;width:100%;height:100%;image-rendering:pixelated}
#share-btn{display:none;position:absolute;bottom:18%;left:50%;transform:translateX(-50%);background:none;border:2px solid #0ff;color:#0ff;font-size:15px;padding:8px 28px;border-radius:24px;cursor:pointer;font-family:inherit;z-index:10;letter-spacing:1px;transition:background .2s,color .2s}
#share-btn:hover{background:#0ff;color:#0b0f1a}
#seo{position:absolute;bottom:0;left:0;width:100%;color:#222;font-size:9px;padding:4px;pointer-events:none;opacity:.01}
</style>
</head>
<body>
<div id="wrap">
<canvas id="c"></canvas>
<button id="share-btn">SHARE</button>
</div>
<div id="seo">
<h1>Neon Bounce - Free HTML5 Game</h1>
<p>Play Neon Bounce online for free. Tap to flip polarity between Pink and Cyan, match platform colors for strong bounces, build combos, and survive as long as you can. A hyper-casual neon-themed HTML5 game playable on desktop and mobile browsers.</p>
</div>
<script>
'use strict';
(()=>{

// ── Canvas setup ──
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const wrap = document.getElementById('wrap');
const shareBtn = document.getElementById('share-btn');
let W, H, dpr;

function resize(){
  const r = wrap.getBoundingClientRect();
  dpr = window.devicePixelRatio || 1;
  W = r.width; H = r.height;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
resize();
window.addEventListener('resize', resize);

// ── Audio ──
let audioCtx = null;
function initAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
function beep(freq, dur, vol, type){
  if(!audioCtx) return;
  try{
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type || 'square';
    o.frequency.value = freq;
    g.gain.value = vol || .08;
    g.gain.exponentialRampToValueAtTime(.001, audioCtx.currentTime + dur);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + dur);
  }catch(e){}
}
function sfxBounce(good){ beep(good ? 520 : 280, .12, .07, 'sine'); }
function sfxPerfect(){ beep(880, .18, .1, 'sine'); setTimeout(()=>beep(1100, .15, .08, 'sine'), 80); }
function sfxShield(){ beep(200, .4, .12, 'sawtooth'); setTimeout(()=>beep(400, .3, .1, 'sine'), 150); }
function sfxOvercharge(){ beep(660, .25, .1, 'triangle'); beep(990, .2, .08, 'sine'); }
function sfxDie(){ beep(180, .5, .15, 'sawtooth'); setTimeout(()=>beep(90, .6, .12, 'sawtooth'), 200); }
function sfxCombo(){ beep(700, .1, .06, 'sine'); }

// ── Constants ──
const PINK = '#ff3399';
const CYAN = '#00ffcc';
const PINK_H = 330;
const CYAN_H = 168;
const BALL_R = 10;
const GRAVITY = 0.38;
const BOUNCE_STRONG = -11.5;
const BOUNCE_WEAK = -6;
const LANE_L = 0.25;
const LANE_R = 0.75;
const PLAT_GAP_MIN = 100;
const PLAT_GAP_MAX = 160;
const PLAT_W_BASE = 80;
const PLAT_W_MIN = 40;
const PLAT_H = 6;
const PERFECT_WINDOW = 18;
const COMBO_DECAY = 0.015;
const OVERCHARGE_H = 4;
const SCROLL_BASE = 2.2;

// ── State ──
let state = 'start';
let score = 0;
let best = parseInt(localStorage.getItem('nb_best')) || 0;
let ball, polarity, platforms, particles, rings;
let scrollSpeed, scrollY, difficulty;
let shieldAvail, shieldActive, shieldTimer;
let slowMo, slowMoTimer;
let shockwave;
let combo, comboMeter, multiplier;
let screenShake, shakeX, shakeY;
let hueShift = 0;
let dustMotes = [];
let gridOffset = 0;
let challengeScore = 0, challengeBy = '';
let flashAlpha = 0;

// ── Challenge from URL ──
function parseChallenge(){
  const p = new URLSearchParams(window.location.search);
  if(p.has('challenge')){
    challengeScore = parseInt(p.get('challenge')) || 0;
    challengeBy = p.get('by') || 'Someone';
  }
}
parseChallenge();

// ── Init ──
function init(){
  ball = { x: W/2, y: H * 0.4, vx: 0, vy: 0 };
  polarity = 0; // 0=pink, 1=cyan
  platforms = [];
  particles = [];
  rings = [];
  scrollSpeed = SCROLL_BASE;
  scrollY = 0;
  difficulty = 0;
  score = 0;
  shieldAvail = true;
  shieldActive = false;
  shieldTimer = 0;
  slowMo = false;
  slowMoTimer = 0;
  shockwave = null;
  combo = 0;
  comboMeter = 0;
  multiplier = 1;
  screenShake = 0;
  shakeX = 0; shakeY = 0;
  flashAlpha = 0;
  dustMotes = [];
  for(let i = 0; i < 25; i++){
    dustMotes.push({ x: Math.random()*W, y: Math.random()*H, s: Math.random()*1.5+.5, a: Math.random()*.3+.05, vx: (Math.random()-.5)*.2, vy: (Math.random()-.5)*.15 });
  }
  // Generate initial platforms
  let py = H * 0.55;
  // Starting platform under ball
  platforms.push(makePlatform(W/2, H * 0.48, PLAT_W_BASE + 20, -1));
  while(py < H + 300){
    const lane = Math.random() < 0.15 ? 0.5 : (Math.random() < 0.5 ? LANE_L : LANE_R);
    const pw = PLAT_W_BASE + Math.random() * 20;
    platforms.push(makePlatform(lane * W, py, pw, -1));
    py += PLAT_GAP_MIN + Math.random() * (PLAT_GAP_MAX - PLAT_GAP_MIN);
  }
}

function makePlatform(x, y, w, pol){
  const p = pol === -1 ? (Math.random() < 0.5 ? 0 : 1) : pol;
  const isCenter = Math.abs(x - W/2) < 20;
  const hasOvercharge = !isCenter && Math.random() < 0.12 + difficulty * 0.02;
  return { x, y, w, h: PLAT_H, pol: p, isCenter, hasOvercharge, hit: false, glow: 0 };
}

// ── Input ──
function handleTap(){
  initAudio();
  if(state === 'start'){ state = 'playing'; init(); return; }
  if(state === 'gameover'){ state = 'playing'; init(); shareBtn.style.display = 'none'; return; }
  if(state === 'playing'){
    polarity = 1 - polarity;
    // Visual flash
    flashAlpha = 0.3;
    beep(polarity ? 600 : 480, .06, .04, 'sine');
  }
}
canvas.addEventListener('pointerdown', (e)=>{ e.preventDefault(); handleTap(); });
document.addEventListener('keydown', (e)=>{
  if(e.code === 'Space' || e.code === 'Enter'){ e.preventDefault(); handleTap(); }
});

// ── Particles ──
function spawnParticles(x, y, color, count, speed){
  for(let i = 0; i < count; i++){
    const a = Math.random() * Math.PI * 2;
    const sp = Math.random() * speed + speed * 0.3;
    particles.push({
      x, y,
      vx: Math.cos(a) * sp,
      vy: Math.sin(a) * sp,
      life: 1,
      decay: 0.015 + Math.random() * 0.025,
      size: Math.random() * 3 + 1.5,
      color
    });
  }
}

function spawnRing(x, y, color){
  rings.push({ x, y, r: 5, maxR: 50, life: 1, color });
}

// ── Update ──
let lastTime = 0;
function update(dt){
  if(state !== 'playing') return;

  const timeScale = slowMo ? 0.3 : 1;
  const adt = dt * timeScale;

  hueShift += dt * 15;
  gridOffset = (gridOffset + scrollSpeed * adt) % 40;
  difficulty = Math.min(score / 800, 1);

  // Scroll
  scrollSpeed = SCROLL_BASE + difficulty * 2.5;
  const scroll = scrollSpeed * adt;

  // Ball physics
  ball.vy += GRAVITY * adt * 60;
  ball.vy = Math.min(ball.vy, 14);
  ball.x += ball.vx * adt * 60;
  ball.y += ball.vy * adt * 60;

  // Wall bounce
  if(ball.x < BALL_R){ ball.x = BALL_R; ball.vx = Math.abs(ball.vx) * 0.6; }
  if(ball.x > W - BALL_R){ ball.x = W - BALL_R; ball.vx = -Math.abs(ball.vx) * 0.6; }

  // Move platforms up
  for(let i = platforms.length - 1; i >= 0; i--){
    platforms[i].y -= scroll;
    if(platforms[i].glow > 0) platforms[i].glow -= dt * 3;
    if(platforms[i].y < -30){
      platforms.splice(i, 1);
    }
  }

  // Generate new platforms below
  let lowest = 0;
  for(const p of platforms) if(p.y > lowest) lowest = p.y;
  while(lowest < H + 200){
    const gap = PLAT_GAP_MIN + Math.random() * (PLAT_GAP_MAX - PLAT_GAP_MIN) - difficulty * 20;
    lowest += Math.max(gap, 80);
    const isCenter = Math.random() < 0.1 + difficulty * 0.05;
    const lane = isCenter ? 0.5 : (Math.random() < 0.5 ? LANE_L : LANE_R);
    const pw = Math.max(PLAT_W_MIN, PLAT_W_BASE - difficulty * 30 + Math.random() * 15);
    platforms.push(makePlatform(lane * W, lowest, pw, -1));
  }

  // Platform collision - swept
  if(ball.vy > 0){
    for(const p of platforms){
      const px1 = p.x - p.w/2;
      const px2 = p.x + p.w/2;
      const py1 = p.y;
      const py2 = p.y + p.h;
      const bBottom = ball.y + BALL_R;
      const bPrevBottom = bBottom - ball.vy * adt * 60;

      if(ball.x + BALL_R > px1 && ball.x - BALL_R < px2){
        if(bPrevBottom <= py1 && bBottom >= py1){
          // Collision!
          ball.y = py1 - BALL_R;

          const match = (polarity === p.pol);
          const centerDist = Math.abs(ball.x - p.x);
          const isPerfect = centerDist < PERFECT_WINDOW;

          // Overcharge strip
          let overchargeHit = false;
          if(p.hasOvercharge){
            const stripX1 = p.x - 8;
            const stripX2 = p.x + 8;
            if(ball.x > stripX1 && ball.x < stripX2){
              overchargeHit = true;
            }
          }

          if(match){
            ball.vy = BOUNCE_STRONG;
            // Slight magnet nudge toward center
            ball.vx += (p.x - ball.x) * 0.04;
            sfxBounce(true);

            let pts = 10;
            if(isPerfect){
              combo++;
              comboMeter = 1;
              multiplier = 1 + combo * 0.5;
              pts = 25;
              sfxPerfect();
              spawnRing(ball.x, ball.y, '#fff');
              spawnParticles(ball.x, ball.y, '#fff', 12, 4);
              sfxCombo();
            } else {
              spawnParticles(ball.x, ball.y, polarity ? CYAN : PINK, 8, 3);
            }

            if(overchargeHit){
              pts += 30;
              multiplier += 0.5;
              sfxOvercharge();
              spawnParticles(ball.x, ball.y, '#ffff00', 15, 5);
              spawnRing(ball.x, ball.y, '#ffff00');
              screenShake = 4;
            }

            score += Math.floor(pts * multiplier);
            p.glow = 1;
            p.hit = true;
          } else {
            // Weak bounce
            ball.vy = BOUNCE_WEAK;
            ball.vx += (Math.random() - 0.5) * 2;
            sfxBounce(false);
            spawnParticles(ball.x, ball.y, '#666', 5, 2);
            combo = 0;
            comboMeter = 0;
            multiplier = 1;
          }
          break;
        }
      }
    }
  }

  // Combo decay
  if(comboMeter > 0){
    comboMeter -= COMBO_DECAY * adt * 60;
    if(comboMeter <= 0){ combo = 0; comboMeter = 0; multiplier = 1; }
  }

  // Slow-mo timer
  if(slowMo){
    slowMoTimer -= dt;
    if(slowMoTimer <= 0){ slowMo = false; }
  }

  // Shockwave
  if(shockwave){
    shockwave.r += 200 * dt;
    shockwave.life -= dt * 2;
    if(shockwave.life <= 0) shockwave = null;
  }

  // Screen shake
  if(screenShake > 0){
    shakeX = (Math.random() - 0.5) * screenShake * 2;
    shakeY = (Math.random() - 0.5) * screenShake * 2;
    screenShake -= dt * 20;
  } else { shakeX = 0; shakeY = 0; }

  // Flash decay
  if(flashAlpha > 0) flashAlpha -= dt * 2;

  // Particles
  for(let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    p.vy += 0.05;
    p.life -= p.decay;
    if(p.life <= 0) particles.splice(i, 1);
  }

  // Rings
  for(let i = rings.length - 1; i >= 0; i--){
    const r = rings[i];
    r.r += (r.maxR - r.r) * 0.08;
    r.life -= dt * 2.5;
    if(r.life <= 0) rings.splice(i, 1);
  }

  // Dust motes
  for(const d of dustMotes){
    d.x += d.vx; d.y += d.vy - scroll * 0.3;
    if(d.y < -5){ d.y = H + 5; d.x = Math.random() * W; }
    if(d.y > H + 5){ d.y = -5; d.x = Math.random() * W; }
    if(d.x < 0) d.x = W;
    if(d.x > W) d.x = 0;
  }

  // Death - fell off bottom
  if(ball.y > H + 50){
    if(shieldAvail){
      // Shield save!
      shieldAvail = false;
      shieldActive = true;
      shieldTimer = 1.5;
      slowMo = true;
      slowMoTimer = 1.0;
      sfxShield();
      shockwave = { x: ball.x, y: H * 0.5, r: 10, life: 1 };
      screenShake = 8;
      spawnParticles(ball.x, ball.y - 50, '#fff', 20, 6);

      // Respawn ball
      ball.y = H * 0.3;
      ball.vy = -3;
      ball.vx = 0;

      // Place a rescue platform
      platforms.push(makePlatform(ball.x, ball.y + 80, PLAT_W_BASE + 30, polarity));
    } else {
      gameOver();
    }
  }

  // Death - flew off top (unlikely but handle)
  if(ball.y < -100){
    if(shieldAvail){
      shieldAvail = false;
      ball.y = 50;
      ball.vy = 2;
    } else {
      gameOver();
    }
  }

  // Shield active timer
  if(shieldActive){
    shieldTimer -= dt;
    if(shieldTimer <= 0) shieldActive = false;
  }

  // Update best
  if(score > best){
    best = score;
    localStorage.setItem('nb_best', best);
  }
}

function gameOver(){
  state = 'gameover';
  screenShake = 12;
  sfxDie();
  spawnParticles(ball.x, ball.y, PINK, 20, 5);
  spawnParticles(ball.x, ball.y, CYAN, 20, 5);
  if(score > best){
    best = score;
    localStorage.setItem('nb_best', best);
  }
  shareBtn.style.display = 'block';
}

// ── Drawing ──
function draw(){
  ctx.save();
  ctx.translate(shakeX, shakeY);

  // Background gradient
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#0b0f1a');
  grad.addColorStop(0.5, '#0d1225');
  grad.addColorStop(1, '#0a0818');
  ctx.fillStyle = grad;
  ctx.fillRect(-20, -20, W + 40, H + 40);

  // Subtle grid
  ctx.strokeStyle = 'rgba(50, 60, 100, 0.08)';
  ctx.lineWidth = 0.5;
  const gSize = 40;
  const gy = gridOffset;
  for(let y = gy - gSize; y < H + gSize; y += gSize){
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
  }
  for(let x = 0; x < W; x += gSize){
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }

  // Dust motes
  for(const d of dustMotes){
    ctx.globalAlpha = d.a;
    ctx.fillStyle = `hsl(${(hueShift + d.x) % 360}, 60%, 70%)`;
    ctx.beginPath();
    ctx.arc(d.x, d.y, d.s, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  if(state === 'playing' || state === 'gameover'){
    // Platforms
    for(const p of platforms){
      const col = p.pol === 0 ? PINK : CYAN;
      const glow = p.glow > 0 ? p.glow : 0;

      // Overcharge strip
      if(p.hasOvercharge && !p.hit){
        ctx.fillStyle = `rgba(255, 255, 0, ${0.4 + Math.sin(Date.now() * 0.008) * 0.2})`;
        ctx.fillRect(p.x - 8, p.y - OVERCHARGE_H, 16, p.h + OVERCHARGE_H * 2);
        ctx.shadowColor = '#ffff00';
        ctx.shadowBlur = 8;
        ctx.fillRect(p.x - 6, p.y, 12, p.h);
        ctx.shadowBlur = 0;
      }

      // Platform body
      ctx.shadowColor = col;
      ctx.shadowBlur = 8 + glow * 15;
      ctx.fillStyle = col;
      ctx.globalAlpha = p.isCenter ? 0.9 : 0.85;

      const rr = 3;
      ctx.beginPath();
      ctx.roundRect(p.x - p.w/2, p.y, p.w, p.h, rr);
      ctx.fill();

      // Center jackpot glow
      if(p.isCenter && !p.hit){
        ctx.globalAlpha = 0.3 + Math.sin(Date.now() * 0.005) * 0.15;
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.roundRect(p.x - p.w/2 + 2, p.y + 1, p.w - 4, p.h - 2, rr);
        ctx.fill();
      }

      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    // Rings
    for(const r of rings){
      ctx.strokeStyle = r.color;
      ctx.globalAlpha = r.life * 0.6;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(r.x, r.y, r.r, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // Particles
    for(const p of particles){
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Shockwave
    if(shockwave){
      ctx.strokeStyle = `rgba(255, 255, 255, ${shockwave.life * 0.5})`;
      ctx.lineWidth = 3 * shockwave.life;
      ctx.beginPath();
      ctx.arc(shockwave.x, shockwave.y, shockwave.r, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Ball
    if(state === 'playing'){
      const bCol = polarity === 0 ? PINK : CYAN;
      const bHue = polarity === 0 ? PINK_H : CYAN_H;

      // Outer glow
      ctx.shadowColor = bCol;
      ctx.shadowBlur = 20;
      ctx.fillStyle = bCol;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI * 2);
      ctx.fill();

      // Inner bright core
      ctx.shadowBlur = 0;
      const coreGrad = ctx.createRadialGradient(ball.x - 2, ball.y - 2, 0, ball.x, ball.y, BALL_R);
      coreGrad.addColorStop(0, '#fff');
      coreGrad.addColorStop(0.4, bCol);
      coreGrad.addColorStop(1, `hsla(${bHue}, 100%, 40%, 0.8)`);
      ctx.fillStyle = coreGrad;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI * 2);
      ctx.fill();

      // Shield indicator
      if(shieldAvail){
        ctx.strokeStyle = 'rgba(255,255,255,0.4)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, BALL_R + 6, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Shield active aura
      if(shieldActive){
        ctx.strokeStyle = `rgba(255,255,255,${shieldTimer / 1.5 * 0.6})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, BALL_R + 10 + Math.sin(Date.now() * 0.01) * 3, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Trail particles
      if(Math.random() < 0.5){
        particles.push({
          x: ball.x + (Math.random() - 0.5) * 6,
          y: ball.y + BALL_R,
          vx: (Math.random() - 0.5) * 0.5,
          vy: Math.random() * 0.5,
          life: 0.5,
          decay: 0.03,
          size: Math.random() * 2 + 0.5,
          color: bCol
        });
      }
    }

    // Polarity flash
    if(flashAlpha > 0){
      ctx.globalAlpha = flashAlpha;
      ctx.fillStyle = polarity ? CYAN : PINK;
      ctx.fillRect(0, 0, W, H);
      ctx.globalAlpha = 1;
    }

    // Slow-mo vignette
    if(slowMo){
      const vigGrad = ctx.createRadialGradient(W/2, H/2, H * 0.3, W/2, H/2, H * 0.7);
      vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
      vigGrad.addColorStop(1, 'rgba(0,0,0,0.4)');
      ctx.fillStyle = vigGrad;
      ctx.fillRect(0, 0, W, H);
    }

    // HUD
    drawHUD();
  }

  // Start screen
  if(state === 'start') drawStart();
  if(state === 'gameover') drawGameOver();

  ctx.restore();
}

function drawHUD(){
  // Score
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 22px "Segoe UI", system-ui, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(score, W/2, 36);

  // Polarity indicator
  const pCol = polarity === 0 ? PINK : CYAN;
  ctx.fillStyle = pCol;
  ctx.shadowColor = pCol;
  ctx.shadowBlur = 10;
  ctx.beginPath();
  ctx.arc(W/2, 52, 4, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Combo meter bar
  if(comboMeter > 0){
    const barW = 100;
    const barH = 4;
    const bx = W/2 - barW/2;
    const by = 60;
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fillRect(bx, by, barW, barH);
    ctx.fillStyle = `hsl(${40 + combo * 20}, 100%, 60%)`;
    ctx.shadowColor = ctx.fillStyle;
    ctx.shadowBlur = 6;
    ctx.fillRect(bx, by, barW * comboMeter, barH);
    ctx.shadowBlur = 0;

    // Multiplier text
    if(multiplier > 1){
      ctx.fillStyle = `hsl(${40 + combo * 20}, 100%, 70%)`;
      ctx.font = 'bold 13px "Segoe UI", system-ui, sans-serif';
      ctx.fillText(`x${multiplier.toFixed(1)}`, W/2, by + 18);
    }
  }

  // Shield icon
  if(shieldAvail){
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.font = '12px "Segoe UI", system-ui, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('◆ SHIELD', 10, 30);
  }
  ctx.textAlign = 'center';
}

function drawStart(){
  // Darken
  ctx.fillStyle = 'rgba(11, 15, 26, 0.7)';
  ctx.fillRect(0, 0, W, H);

  // Title
  ctx.textAlign = 'center';
  ctx.fillStyle = '#fff';
  ctx.shadowColor = CYAN;
  ctx.shadowBlur = 30;
  ctx.font = 'bold 36px "Segoe UI", system-ui, sans-serif';
  ctx.fillText('NEON', W/2, H * 0.3);
  ctx.shadowColor = PINK;
  ctx.fillText('BOUNCE', W/2, H * 0.3 + 42);
  ctx.shadowBlur = 0;

  // Subtitle
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.font = '13px "Segoe UI", system-ui, sans-serif';
  ctx.fillText('Polarity Bounce', W/2, H * 0.3 + 70);

  // Challenge
  if(challengeScore > 0){
    ctx.fillStyle = '#ffff00';
    ctx.font = 'bold 14px "Segoe UI", system-ui, sans-serif';
    ctx.fillText(`${challengeBy} challenges you!`, W/2, H * 0.5);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px "Segoe UI", system-ui, sans-serif';
    ctx.fillText(`Beat ${challengeScore} pts`, W/2, H * 0.5 + 28);
  }

  // Best score
  if(best > 0){
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.font = '14px "Segoe UI", system-ui, sans-serif';
    ctx.fillText(`Best: ${best}`, W/2, H * 0.62);
  }

  // Tap prompt
  const pulse = 0.5 + Math.sin(Date.now() * 0.004) * 0.3;
  ctx.globalAlpha = pulse;
  ctx.fillStyle = '#fff';
  ctx.font = '16px "Segoe UI", system-ui, sans-serif';
  ctx.fillText('Tap to Start', W/2, H * 0.75);
  ctx.globalAlpha = 1;

  // Instructions
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.font = '11px "Segoe UI", system-ui, sans-serif';
  ctx.fillText('Tap to flip polarity', W/2, H * 0.82);
  ctx.fillText('Match colors for strong bounces', W/2, H * 0.82 + 18);
}

function drawGameOver(){
  // Darken
  ctx.fillStyle = 'rgba(11, 15, 26, 0.75)';
  ctx.fillRect(0, 0, W, H);

  ctx.textAlign = 'center';

  // Game Over
  ctx.fillStyle = '#fff';
  ctx.shadowColor = '#ff3366';
  ctx.shadowBlur = 20;
  ctx.font = 'bold 30px "Segoe UI", system-ui, sans-serif';
  ctx.fillText('GAME OVER', W/2, H * 0.3);
  ctx.shadowBlur = 0;

  // Score
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 48px "Segoe UI", system-ui, sans-serif';
  ctx.fillText(score, W/2, H * 0.42);

  // Best
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.font = '15px "Segoe UI", system-ui, sans-serif';
  ctx.fillText(`Best: ${best}`, W/2, H * 0.48);

  // New best
  if(score >= best && score > 0){
    ctx.fillStyle = '#ffff00';
    ctx.font = 'bold 14px "Segoe UI", system-ui, sans-serif';
    ctx.fillText('NEW BEST!', W/2, H * 0.53);
  }

  // Challenge result
  if(challengeScore > 0){
    const won = score > challengeScore;
    ctx.fillStyle = won ? '#00ff88' : '#ff4466';
    ctx.font = 'bold 14px "Segoe UI", system-ui, sans-serif';
    ctx.fillText(won ? `You beat ${challengeBy}!` : `${challengeBy} wins this time`, W/2, H * 0.58);
  }

  // Retry prompt
  const pulse = 0.5 + Math.sin(Date.now() * 0.004) * 0.3;
  ctx.globalAlpha = pulse;
  ctx.fillStyle = '#fff';
  ctx.font = '16px "Segoe UI", system-ui, sans-serif';
  ctx.fillText('Tap to Retry', W/2, H * 0.72);
  ctx.globalAlpha = 1;
}

// ── Share ──
shareBtn.addEventListener('click', (e)=>{
  e.stopPropagation();
  const text = `I scored ${score} in Neon Bounce! Can you beat me?`;
  const url = `https://balinti.github.io/neon-bounce/?challenge=${score}&by=Player`;
  if(navigator.share){
    navigator.share({ title: 'Neon Bounce', text, url }).catch(()=>{});
  } else {
    navigator.clipboard.writeText(`${text} ${url}`).then(()=>{
      shareBtn.textContent = 'COPIED!';
      setTimeout(()=>{ shareBtn.textContent = 'SHARE'; }, 1500);
    }).catch(()=>{});
  }
});

// ── Game Loop ──
function loop(ts){
  const dt = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts;

  resize();
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

// Kick off
init();
requestAnimationFrame((ts)=>{ lastTime = ts; loop(ts); });

})();
</script>
</body>
</html>