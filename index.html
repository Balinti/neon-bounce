<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Neon Bounce - Free HTML5 Game</title>
<meta name="description" content="Play Neon Bounce - Tap to bounce a glowing ball between neon platforms. Miss a platform and fall into the void. Platforms get narrower as score increases.">
<meta name="theme-color" content="#0a0a1a">
<link rel="canonical" href="https://balinti.github.io/neon-bounce/">
<meta property="og:type" content="website">
<meta property="og:title" content="Neon Bounce - Free HTML5 Game">
<meta property="og:description" content="Play Neon Bounce - Tap to bounce a glowing ball between neon platforms. Miss a platform and fall into the void.">
<meta property="og:url" content="https://balinti.github.io/neon-bounce/">
<meta property="og:image" content="https://balinti.github.io/neon-bounce/og-image.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Neon Bounce - Free HTML5 Game">
<meta name="twitter:description" content="Play Neon Bounce - Tap to bounce a glowing ball between neon platforms. Miss a platform and fall into the void.">
<meta name="twitter:image" content="https://balinti.github.io/neon-bounce/og-image.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow-x:hidden;background:#05050f;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;color:#ccc}
#ad-top{width:100%;max-width:420px;height:50px;margin:0 auto;background:transparent;flex-shrink:0}
#page{display:flex;flex-direction:column;align-items:center;min-height:100vh;min-height:100dvh}
#wrap{position:relative;width:100%;max-width:420px;flex-shrink:0}
canvas{display:block;width:100%;touch-action:none;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;border-radius:4px}
#seo{max-width:420px;width:100%;margin:18px auto 40px;padding:0 14px;font-size:13px;line-height:1.65;color:#7778a0}
#seo h2{font-size:15px;color:#99a0cc;margin:14px 0 4px}
#seo ul{padding-left:20px}
#seo li{margin-bottom:3px}
@media(max-height:600px){#ad-top{height:30px}}
</style>
</head>
<body>
<div id="page">
<div id="ad-top"></div>
<div id="wrap"><canvas id="c"></canvas></div>
</div>
<div id="seo">
<h2>How to Play</h2>
<ul>
<li>Tap or press Space / Enter to switch between the Safe and Risk lanes.</li>
<li>The ball auto-bounces on a steady beat. Time your lane switch before each landing.</li>
<li>Land on Risk lane for a higher multiplier; Safe lane is easier but your multiplier decays.</li>
<li>Hit the Perfect Zone (bright center of a platform) to build Charge.</li>
<li>When Charge is full, tap to arm Dash Bounce &mdash; skip a gap and score big!</li>
</ul>
<h2>Tips</h2>
<ul>
<li>Chain perfects to rack up streak bonuses and fill your charge faster.</li>
<li>Risk lane platforms move and have gaps &mdash; watch the pattern before switching.</li>
<li>Use Dash strategically to survive tough gap sequences.</li>
<li>Difficulty increases over time: platforms get trickier, tempo rises slightly.</li>
</ul>
</div>
<script>
'use strict';
(()=>{

/* ═══════════════════════════════════════════
   DESIGN-SPACE CONSTANTS
   ═══════════════════════════════════════════ */
const DW = 420, DH = 750;
const LS_KEY = 'neonBounceHighScore';

// Physics
const GRAVITY     = 0.48;
const BOUNCE_VEL  = -11.2;
const BALL_R      = 10;

// Lanes
const SAFE_CX = DW * 0.27;
const RISK_CX = DW * 0.73;
const LANE_LERP = 0.16;

// Platforms
const PLAT_H           = 10;
const BASE_SAFE_W      = 125;
const BASE_RISK_W      = 85;
const MIN_PLAT_W       = 42;
const PLAT_SPACING_MIN = 50;
const PLAT_SPACING_MAX = 62;
const PERFECT_RATIO    = 0.24;  // fraction of width that's "perfect"
const MIN_PERFECT_FRAC = 0.13;

// Beat / tempo
const BASE_BEAT_FRAMES = 48;
const MIN_BEAT_FRAMES  = 28;

// Charge / dash
const CHARGE_MAX        = 100;
const CHARGE_ON_LAND    = 7;
const CHARGE_ON_PERFECT = 20;
const CHARGE_RISK_BONUS = 5;
const DASH_SCORE_BONUS  = 500;

// Scoring
const PICKUP_SCORE = 200;

// Particles
const MAX_P = 500;

// Shake
const SHAKE_DECAY = 0.86;

/* ═══════════════════════════════════════════
   CANVAS SETUP
   ═══════════════════════════════════════════ */
const canvas = document.getElementById('c');
const ctx    = canvas.getContext('2d');
let dpr = 1;

function resize() {
  const wrap = document.getElementById('wrap');
  const adH  = document.getElementById('ad-top').offsetHeight || 50;
  const maxH = Math.min(window.innerHeight - adH - 8, 750);
  const maxW = Math.min(window.innerWidth, 420);
  const s    = Math.min(maxW / DW, maxH / DH);
  const cw   = Math.floor(DW * s);
  const ch   = Math.floor(DH * s);
  canvas.style.width  = cw + 'px';
  canvas.style.height = ch + 'px';
  dpr = window.devicePixelRatio || 1;
  canvas.width  = Math.floor(DW * dpr);
  canvas.height = Math.floor(DH * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', resize);
resize();

/* ═══════════════════════════════════════════
   GAME STATE
   ═══════════════════════════════════════════ */
let state = 'start';  // start | playing | gameover

let score, bestScore, multiplier, perfectStreak;
let charge, dashReady, dashArmed, ghostSkip;

let ballX, ballY, ballVY;
let ballLane, targetLane;   // 0 = safe, 1 = risk

let beatInterval;
let scrollY;
let platforms;

let hueBase, tick;
let shakeX, shakeY, shakePow;
let gameOverTimer;

/* ═══════════════════════════════════════════
   PARTICLE POOL (no GC)
   ═══════════════════════════════════════════ */
const PP = new Array(MAX_P);
for (let i = 0; i < MAX_P; i++) PP[i] = { alive: false };
let pi = 0;

function emit(x, y, count, hue, speed, life, sz, type) {
  for (let i = 0; i < count; i++) {
    const a = Math.random() * 6.2832;
    const v = Math.random() * speed;
    const p = PP[pi]; pi = (pi + 1) % MAX_P;
    p.alive = true;
    p.x = x; p.y = y;
    p.vx = Math.cos(a) * v;
    p.vy = Math.sin(a) * v - speed * 0.25;
    p.life = p.maxLife = life;
    p.hue = hue + Math.random() * 30 - 15;
    p.size = sz * (0.5 + Math.random() * 0.5);
    p.type = type || 0;  // 0=spark,1=ring,2=comet
    p.radius = 0;
    p.targetR = 0;
  }
}

function emitRing(x, y, hue, maxR) {
  const p = PP[pi]; pi = (pi + 1) % MAX_P;
  p.alive = true;
  p.x = x; p.y = y;
  p.vx = 0; p.vy = 0;
  p.life = p.maxLife = 28;
  p.hue = hue;
  p.size = 0;
  p.type = 1;
  p.radius = 0;
  p.targetR = maxR;
}

function tickParticles() {
  for (let i = 0; i < MAX_P; i++) {
    const p = PP[i];
    if (!p.alive) continue;
    if (--p.life <= 0) { p.alive = false; continue; }
    if (p.type === 1) {
      p.radius += (p.targetR - p.radius) * 0.14;
    } else {
      p.x += p.vx; p.y += p.vy;
      p.vy += 0.07;
      p.vx *= 0.97;
    }
  }
}

function drawParticles() {
  for (let i = 0; i < MAX_P; i++) {
    const p = PP[i];
    if (!p.alive) continue;
    const a = p.life / p.maxLife;
    ctx.globalAlpha = a * 0.85;
    if (p.type === 1) {
      ctx.strokeStyle = `hsl(${p.hue},90%,65%)`;
      ctx.lineWidth = 2.5 * a;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius, 0, 6.2832);
      ctx.stroke();
    } else if (p.type === 2) {
      ctx.fillStyle = `hsl(${p.hue},100%,80%)`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * a, 0, 6.2832);
      ctx.fill();
    } else {
      ctx.fillStyle = `hsl(${p.hue},85%,65%)`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * a, 0, 6.2832);
      ctx.fill();
    }
  }
  ctx.globalAlpha = 1;
}

/* ═══════════════════════════════════════════
   DIFFICULTY
   ═══════════════════════════════════════════ */
function diff() { return Math.min(score / 4000, 1); }

/* ═══════════════════════════════════════════
   PLATFORMS
   ═══════════════════════════════════════════ */
function safeW() { return Math.max(BASE_SAFE_W - diff() * 45, MIN_PLAT_W + 15); }
function riskW() { return Math.max(BASE_RISK_W - diff() * 30, MIN_PLAT_W); }

function makePlat(y, lane) {
  const d = diff();
  const w = lane === 0 ? safeW() : riskW();
  const cx = lane === 0 ? SAFE_CX : RISK_CX;
  const moving = lane === 1 && Math.random() < Math.min(0.12 + d * 0.42, 0.56);
  const gapChance = lane === 1
    ? Math.min(0.04 + d * 0.28, 0.34)
    : Math.min(0.0 + d * 0.12, 0.14);
  const gapped = Math.random() < gapChance;
  const hasPickup = !gapped && Math.random() < 0.10;
  const perfFrac = Math.max(PERFECT_RATIO * (1 - d * 0.35), MIN_PERFECT_FRAC);
  return {
    x: cx, y, w, lane,
    moving, mAmp: moving ? (18 + Math.random() * 18) : 0,
    mSpd: moving ? (0.012 + Math.random() * 0.014) : 0,
    mPh: Math.random() * 6.2832,
    gapped,
    perfW: w * perfFrac,
    hasPickup, pkCollected: false
  };
}

function initPlatforms() {
  platforms = [];
  // solid starting platform under ball
  platforms.push({
    x: SAFE_CX, y: ballY + 55, w: 150, lane: 0,
    moving: false, mAmp: 0, mSpd: 0, mPh: 0,
    gapped: false, perfW: 150 * PERFECT_RATIO,
    hasPickup: false, pkCollected: false
  });
  for (let i = 1; i < 16; i++) {
    const lane = (i % 3 === 0) ? 1 : 0;
    const sp = PLAT_SPACING_MIN + Math.random() * (PLAT_SPACING_MAX - PLAT_SPACING_MIN);
    platforms.push(makePlat(platforms[platforms.length - 1].y + sp, lane));
  }
}

function spawnBelow() {
  const last = platforms[platforms.length - 1];
  const sp = PLAT_SPACING_MIN + Math.random() * (PLAT_SPACING_MAX - PLAT_SPACING_MIN);
  const lane = Math.random() < (0.32 + diff() * 0.22) ? 1 : 0;
  platforms.push(makePlat(last.y + sp, lane));
}

/* ═══════════════════════════════════════════
   INIT / RESET
   ═══════════════════════════════════════════ */
function loadBest() {
  try { bestScore = parseInt(localStorage.getItem(LS_KEY)) || 0; } catch(e) { bestScore = 0; }
}
function saveBest() {
  try { localStorage.setItem(LS_KEY, bestScore); } catch(e) {}
}

function initGame() {
  score = 0; multiplier = 1; perfectStreak = 0;
  charge = 0; dashReady = false; dashArmed = false; ghostSkip = false;
  ballLane = 0; targetLane = 0;
  ballX = SAFE_CX; ballY = 200; ballVY = 0;
  beatInterval = BASE_BEAT_FRAMES;
  scrollY = 0;
  hueBase = 180; tick = 0;
  shakeX = 0; shakeY = 0; shakePow = 0;
  gameOverTimer = 0;
  for (let i = 0; i < MAX_P; i++) PP[i].alive = false;
  pi = 0;
  loadBest();
  initPlatforms();
}

/* ═══════════════════════════════════════════
   SHAKE
   ═══════════════════════════════════════════ */
function addShake(pow) { shakePow = Math.max(shakePow, pow); }
function tickShake() {
  if (shakePow > 0.4) {
    shakeX = (Math.random() - 0.5) * shakePow;
    shakeY = (Math.random() - 0.5) * shakePow;
    shakePow *= SHAKE_DECAY;
  } else { shakeX = shakeY = shakePow = 0; }
}

/* ═══════════════════════════════════════════
   INPUT
   ═══════════════════════════════════════════ */
function onInput() {
  if (state === 'start') {
    state = 'playing';
    initGame();
    ballVY = BOUNCE_VEL;
    return;
  }
  if (state === 'gameover') {
    if (gameOverTimer > 35) {
      state = 'playing';
      initGame();
      ballVY = BOUNCE_VEL;
    }
    return;
  }
  // playing
  if (dashReady && !dashArmed) {
    dashArmed = true;
    dashReady = false;
    emit(ballX, ballY, 10, 55, 3.5, 22, 4, 2);
    return;
  }
  // lane switch
  targetLane = targetLane === 0 ? 1 : 0;
}

canvas.addEventListener('pointerdown', e => { e.preventDefault(); onInput(); });
window.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'Enter') { e.preventDefault(); onInput(); }
});

/* ═══════════════════════════════════════════
   COLLISION
   ═══════════════════════════════════════════ */
function checkLanding() {
  if (ballVY <= 0) return null;
  for (let i = 0; i < platforms.length; i++) {
    const p = platforms[i];
    if (p.gapped) continue;
    let px = p.x;
    if (p.moving) px += Math.sin(tick * p.mSpd + p.mPh) * p.mAmp;
    const hw = p.w / 2;
    if (ballX >= px - hw && ballX <= px + hw &&
        ballY + BALL_R >= p.y && ballY + BALL_R <= p.y + PLAT_H + Math.max(ballVY, 0) + 2) {
      return { plat: p, px };
    }
  }
  return null;
}

/* ═══════════════════════════════════════════
   UPDATE – PLAYING
   ═══════════════════════════════════════════ */
function updatePlaying() {
  tick++;
  hueBase = (hueBase + 0.18) % 360;
  const d = diff();

  // tempo
  beatInterval = Math.max(BASE_BEAT_FRAMES - d * 20, MIN_BEAT_FRAMES);

  // lane lerp
  const lx = targetLane === 0 ? SAFE_CX : RISK_CX;
  ballX += (lx - ballX) * LANE_LERP;
  ballLane = targetLane;

  // physics
  ballVY += GRAVITY;
  ballY += ballVY;

  // dash comet trail
  if (dashArmed && tick % 2 === 0) {
    emit(ballX + (Math.random() - 0.5) * 6, ballY + BALL_R, 1, 50 + hueBase * 0.15, 1.2, 16, 3, 2);
  }

  // landing check
  const hit = checkLanding();
  if (hit) {
    const { plat, px } = hit;
    ballY = plat.y - BALL_R;
    ballVY = BOUNCE_VEL;

    // base score
    const base = 10 * multiplier;
    score += Math.floor(base);

    // perfect?
    const dist = Math.abs(ballX - px);
    const isPerfect = dist < plat.perfW / 2;
    if (isPerfect) {
      perfectStreak++;
      score += Math.floor(25 * multiplier + perfectStreak * 5);
      charge = Math.min(charge + CHARGE_ON_PERFECT, CHARGE_MAX);
      emitRing(ballX, plat.y, 190 + hueBase * 0.4, 45);
      emit(ballX, plat.y, 14, 190 + hueBase * 0.4, 4.5, 26, 3, 0);
      addShake(3.5);
    } else {
      perfectStreak = 0;
      charge = Math.min(charge + CHARGE_ON_LAND, CHARGE_MAX);
    }

    // multiplier: risk grows, safe decays
    if (plat.lane === 1) {
      multiplier = Math.min(multiplier + 0.18, 5);
      charge = Math.min(charge + CHARGE_RISK_BONUS, CHARGE_MAX);
    } else {
      multiplier = Math.max(multiplier - 0.06, 1);
    }

    // dash consume
    if (dashArmed) {
      dashArmed = false;
      ghostSkip = true;
      score += DASH_SCORE_BONUS;
      emit(ballX, plat.y, 28, 52, 7, 32, 5, 0);
      emitRing(ballX, plat.y, 52, 65);
      addShake(7);
      charge = 0;
    }

    // pickup
    if (plat.hasPickup && !plat.pkCollected) {
      plat.pkCollected = true;
      score += Math.floor(PICKUP_SCORE * multiplier);
      emit(px, plat.y - 14, 12, 130, 3.5, 22, 4, 0);
    }

    // landing sparks
    emit(ballX, plat.y, 7, hueBase, 2.8, 18, 2.5, 0);

    // dash ready?
    if (charge >= CHARGE_MAX && !dashReady && !dashArmed) {
      dashReady = true;
    }
  }

  // ghost skip: survive one gap
  if (ghostSkip && ballVY > 2) {
    for (let i = 0; i < platforms.length; i++) {
      const p = platforms[i];
      if (p.gapped && Math.abs(ballX - (p.lane === 0 ? SAFE_CX : RISK_CX)) < 60 &&
          ballY + BALL_R >= p.y - 10 && ballY + BALL_R <= p.y + 30) {
        ghostSkip = false;
        // rescue bounce
        ballY = p.y - BALL_R;
        ballVY = BOUNCE_VEL;
        score += 100;
        emit(ballX, p.y, 18, 55, 5.5, 26, 4, 0);
        emitRing(ballX, p.y, 55, 55);
        addShake(4);
        break;
      }
    }
  }

  // scroll: keep ball near fixed screen Y
  const targetSY = ballY - 240;
  scrollY += (targetSY - scrollY) * 0.09;

  // cull above, spawn below
  while (platforms.length > 0 && platforms[0].y < scrollY - 80) platforms.shift();
  while (platforms.length < 18) spawnBelow();

  // death
  if (ballY > scrollY + DH + 60) {
    if (ghostSkip) {
      ghostSkip = false;
      ballVY = BOUNCE_VEL;
      emit(ballX, ballY, 16, 55, 5, 26, 4, 0);
    } else {
      doDeath();
    }
  }

  tickShake();
  tickParticles();
}

function doDeath() {
  state = 'gameover';
  gameOverTimer = 0;
  emit(ballX, ballY, 45, 0, 8, 38, 5, 0);
  emitRing(ballX, ballY, 0, 85);
  addShake(16);
  if (score > bestScore) { bestScore = score; saveBest(); }
}

/* ═══════════════════════════════════════════
   DRAW HELPERS
   ═══════════════════════════════════════════ */
function roundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

/* ═══════════════════════════════════════════
   DRAW – BACKGROUND
   ═══════════════════════════════════════════ */
function drawBg() {
  const g = ctx.createLinearGradient(0, 0, 0, DH);
  g.addColorStop(0, '#06061a');
  g.addColorStop(0.45, '#0a0a2c');
  g.addColorStop(1, '#050518');
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, DW, DH);
}

/* ═══════════════════════════════════════════
   DRAW – LANES
   ═══════════════════════════════════════════ */
function drawLanes() {
  const d = diff();
  // safe
  ctx.globalAlpha = 0.055;
  const sw = safeW() + 65;
  ctx.fillStyle = `hsl(${(175 + hueBase * 0.08) % 360},55%,38%)`;
  ctx.fillRect(SAFE_CX - sw / 2, 0, sw, DH);
  // risk
  const rw = riskW() + 55;
  ctx.fillStyle = `hsl(${(32 + hueBase * 0.15 + multiplier * 8) % 360},65%,42%)`;
  ctx.fillRect(RISK_CX - rw / 2, 0, rw, DH);
  ctx.globalAlpha = 1;

  // divider
  ctx.save();
  ctx.strokeStyle = `hsla(${hueBase % 360},40%,35%,0.12)`;
  ctx.lineWidth = 1;
  ctx.setLineDash([5, 9]);
  ctx.beginPath();
  ctx.moveTo(DW / 2, 0);
  ctx.lineTo(DW / 2, DH);
  ctx.stroke();
  ctx.restore();

  // lane labels (faint)
  ctx.globalAlpha = 0.12;
  ctx.fillStyle = '#fff';
  ctx.font = '10px "Segoe UI",system-ui,sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('SAFE', SAFE_CX, DH - 10);
  ctx.fillText('RISK', RISK_CX, DH - 10);
  ctx.globalAlpha = 1;
}

/* ═══════════════════════════════════════════
   DRAW – PLATFORMS
   ═══════════════════════════════════════════ */
function drawPlatforms() {
  const oY = -scrollY;
  for (let i = 0; i < platforms.length; i++) {
    const p = platforms[i];
    const py = p.y + oY;
    if (py < -25 || py > DH + 25) continue;

    if (p.gapped) {
      // gap indicator
      ctx.globalAlpha = 0.1;
      ctx.strokeStyle = `hsl(0,70%,50%)`;
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 6]);
      const gx = p.lane === 0 ? SAFE_CX : RISK_CX;
      ctx.beginPath();
      ctx.moveTo(gx - 28, py + 4);
      ctx.lineTo(gx + 28, py + 4);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.globalAlpha = 1;
      continue;
    }

    let px = p.x;
    if (p.moving) px += Math.sin(tick * p.mSpd + p.mPh) * p.mAmp;
    const hw = p.w / 2;

    const hue = p.lane === 0
      ? (172 + hueBase * 0.08) % 360
      : (32 + hueBase * 0.22 + multiplier * 10) % 360;
    const sat = p.lane === 0 ? 58 : Math.min(68 + multiplier * 5, 90);

    // glow + body
    ctx.shadowColor = `hsl(${hue},${sat}%,55%)`;
    ctx.shadowBlur = 10;
    ctx.fillStyle = `hsl(${hue},${sat}%,48%)`;
    roundRect(px - hw, py, p.w, PLAT_H, 4);
    ctx.fill();
    ctx.shadowBlur = 0;

    // perfect zone
    const phw = p.perfW / 2;
    ctx.fillStyle = `hsla(${(hue + 55) % 360},90%,72%,0.32)`;
    ctx.fillRect(px - phw, py + 1, phw * 2, PLAT_H - 2);

    // pickup orb
    if (p.hasPickup && !p.pkCollected) {
      const pkY = py - 16;
      const pkHue = (hueBase + 125) % 360;
      ctx.fillStyle = `hsl(${pkHue},88%,62%)`;
      ctx.shadowColor = `hsl(${pkHue},88%,62%)`;
      ctx.shadowBlur = 9;
      ctx.beginPath();
      ctx.arc(px, pkY, 5 + Math.sin(tick * 0.09) * 1.4, 0, 6.2832);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  }
}

/* ═══════════════════════════════════════════
   DRAW – BALL
   ═══════════════════════════════════════════ */
function drawBall() {
  const oY = -scrollY;
  const bx = ballX;
  const by = ballY + oY;
  const hue = dashArmed ? 50 : (dashReady ? 125 : hueBase);
  const lit = dashArmed ? 80 : (dashReady ? 72 : 65);

  // outer glow
  ctx.shadowColor = `hsl(${hue},90%,${lit}%)`;
  ctx.shadowBlur = dashArmed ? 24 : 14;
  ctx.fillStyle = `hsl(${hue},90%,${lit}%)`;
  ctx.beginPath();
  ctx.arc(bx, by, BALL_R, 0, 6.2832);
  ctx.fill();

  // bright core
  ctx.shadowBlur = 0;
  ctx.fillStyle = `hsla(${hue},100%,92%,0.55)`;
  ctx.beginPath();
  ctx.arc(bx - 2, by - 2, BALL_R * 0.42, 0, 6.2832);
  ctx.fill();

  // ghost skip aura
  if (ghostSkip) {
    ctx.strokeStyle = `hsla(50,100%,70%,${0.3 + Math.sin(tick * 0.15) * 0.2})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(bx, by, BALL_R + 7, 0, 6.2832);
    ctx.stroke();
  }
}

/* ═══════════════════════════════════════════
   DRAW – HUD
   ═══════════════════════════════════════════ */
function drawHUD() {
  ctx.textAlign = 'center';

  // score
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 24px "Segoe UI",system-ui,sans-serif';
  ctx.fillText(Math.floor(score), DW / 2, 36);

  // best
  ctx.font = '11px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle = '#7778aa';
  ctx.fillText('BEST ' + bestScore, DW / 2, 52);

  // multiplier
  const mHue = 30 + multiplier * 22;
  ctx.fillStyle = `hsl(${mHue},80%,60%)`;
  ctx.font = 'bold 14px "Segoe UI",system-ui,sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText('x' + multiplier.toFixed(1), 12, 32);

  // perfect streak
  if (perfectStreak > 1) {
    ctx.fillStyle = `hsl(${(190 + hueBase * 0.25) % 360},80%,70%)`;
    ctx.font = 'bold 12px "Segoe UI",system-ui,sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('PERFECT x' + perfectStreak, DW - 12, 32);
  }

  // charge bar
  const barW = 82, barH = 6, barX = DW / 2 - barW / 2, barY = 60;
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  roundRect(barX, barY, barW, barH, 3);
  ctx.fill();

  const fill = charge / CHARGE_MAX;
  const cHue = dashReady ? 125 : (dashArmed ? 50 : 210);
  ctx.fillStyle = `hsl(${cHue},80%,52%)`;
  if (fill > 0) {
    roundRect(barX, barY, barW * fill, barH, 3);
    ctx.fill();
  }
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;
  roundRect(barX, barY, barW, barH, 3);
  ctx.stroke();

  // dash text
  ctx.textAlign = 'center';
  if (dashReady) {
    ctx.fillStyle = `hsl(125,90%,65%)`;
    ctx.font = 'bold 11px "Segoe UI",system-ui,sans-serif';
    ctx.fillText('DASH READY', DW / 2, barY + barH + 15);
  } else if (dashArmed) {
    const da = 0.6 + Math.sin(tick * 0.12) * 0.3;
    ctx.globalAlpha = da;
    ctx.fillStyle = `hsl(50,95%,65%)`;
    ctx.font = 'bold 12px "Segoe UI",system-ui,sans-serif';
    ctx.fillText('DASH ARMED!', DW / 2, barY + barH + 15);
    ctx.globalAlpha = 1;
  }
}

/* ═══════════════════════════════════════════
   DRAW – START SCREEN
   ═══════════════════════════════════════════ */
function drawStartScreen() {
  drawBg();

  // decorative lane preview
  ctx.globalAlpha = 0.04;
  ctx.fillStyle = `hsl(172,55%,45%)`;
  ctx.fillRect(SAFE_CX - 65, DH * 0.65, 130, DH * 0.3);
  ctx.fillStyle = `hsl(35,65%,45%)`;
  ctx.fillRect(RISK_CX - 55, DH * 0.65, 110, DH * 0.3);
  ctx.globalAlpha = 1;

  // title
  ctx.textAlign = 'center';
  ctx.fillStyle = `hsl(${hueBase},80%,68%)`;
  ctx.shadowColor = `hsl(${hueBase},90%,60%)`;
  ctx.shadowBlur = 25;
  ctx.font = 'bold 46px "Segoe UI",system-ui,sans-serif';
  ctx.fillText('NEON', DW / 2, DH * 0.28);
  ctx.fillStyle = `hsl(${(hueBase + 40) % 360},85%,68%)`;
  ctx.shadowColor = `hsl(${(hueBase + 40) % 360},90%,60%)`;
  ctx.fillText('BOUNCE', DW / 2, DH * 0.28 + 50);
  ctx.shadowBlur = 0;

  // subtitle
  ctx.fillStyle = '#7778aa';
  ctx.font = '13px "Segoe UI",system-ui,sans-serif';
  ctx.fillText('Split lanes \u2022 Perfect landings \u2022 Dash through', DW / 2, DH * 0.38);

  // best
  if (bestScore > 0) {
    ctx.fillStyle = '#9999bb';
    ctx.font = '13px "Segoe UI",system-ui,sans-serif';
    ctx.fillText('Best: ' + bestScore, DW / 2, DH * 0.44);
  }

  // tap to start
  const pulse = 0.45 + Math.sin(tick * 0.055) * 0.35;
  ctx.globalAlpha = pulse;
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 19px "Segoe UI",system-ui,sans-serif';
  ctx.fillText('Tap to Start', DW / 2, DH * 0.55);
  ctx.globalAlpha = 1;

  // controls
  ctx.fillStyle = '#555570';
  ctx.font = '11px "Segoe UI",system-ui,sans-serif';
  ctx.fillText('Space / Enter / Tap to switch lanes', DW / 2, DH * 0.62);
}

/* ═══════════════════════════════════════════
   DRAW – GAMEOVER SCREEN
   ═══════════════════════════════════════════ */
function drawGameOverScreen() {
  const a = Math.min(gameOverTimer / 30, 0.72);
  ctx.fillStyle = `rgba(5,5,18,${a})`;
  ctx.fillRect(0, 0, DW, DH);

  if (gameOverTimer > 14) {
    ctx.textAlign = 'center';

    ctx.fillStyle = '#ff4466';
    ctx.shadowColor = '#ff4466';
    ctx.shadowBlur = 18;
    ctx.font = 'bold 38px "Segoe UI",system-ui,sans-serif';
    ctx.fillText('GAME OVER', DW / 2, DH * 0.30);
    ctx.shadowBlur = 0;

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 30px "Segoe UI",system-ui,sans-serif';
    ctx.fillText(Math.floor(score), DW / 2, DH * 0.40);

    ctx.fillStyle = '#9999bb';
    ctx.font = '14px "Segoe UI",system-ui,sans-serif';
    ctx.fillText('Best: ' + bestScore, DW / 2, DH * 0.46);

    if (score >= bestScore && score > 0) {
      ctx.fillStyle = `hsl(${(hueBase + 60) % 360},90%,65%)`;
      ctx.font = 'bold 16px "Segoe UI",system-ui,sans-serif';
      ctx.fillText('NEW BEST!', DW / 2, DH * 0.52);
    }
  }

  if (gameOverTimer > 35) {
    const pulse = 0.45 + Math.sin(tick * 0.055) * 0.35;
    ctx.globalAlpha = pulse;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 17px "Segoe UI",system-ui,sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Tap to Retry', DW / 2, DH * 0.63);
    ctx.globalAlpha = 1;
  }
}

/* ═══════════════════════════════════════════
   MAIN LOOP
   ═══════════════════════════════════════════ */
function frame() {
  requestAnimationFrame(frame);
  tick++;
  hueBase = ((hueBase || 180) + 0.18) % 360;

  ctx.save();
  ctx.translate(shakeX || 0, shakeY || 0);

  if (state === 'start') {
    drawStartScreen();
  } else if (state === 'playing') {
    updatePlaying();
    drawBg();
    drawLanes();
    drawPlatforms();
    drawBall();
    drawParticles();
    drawHUD();
  } else if (state === 'gameover') {
    gameOverTimer++;
    tickShake();
    tickParticles();
    drawBg();
    drawLanes();
    drawPlatforms();
    drawBall();
    drawParticles();
    drawGameOverScreen();
  }

  ctx.restore();
}

/* ═══════════════════════════════════════════
   BOOT
   ═══════════════════════════════════════════ */
loadBest();
initGame();
state = 'start';
requestAnimationFrame(frame);

})();
</script>
</body>
</html>
