<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Neon Bounce - Free HTML5 Game</title>
<meta name="description" content="Play Neon Bounce - Tap to bounce a glowing ball between neon platforms. Miss a platform and fall into the void. Platforms get narrower as score increases.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0a0014">
<meta property="og:type" content="website">
<meta property="og:title" content="Neon Bounce - Free HTML5 Game">
<meta property="og:description" content="Play Neon Bounce - Tap to bounce a glowing ball between neon platforms. Miss a platform and fall into the void. Platforms get narrower as score increases.">
<meta property="og:url" content="https://balinti.github.io/neon-bounce/">
<meta property="og:image" content="https://balinti.github.io/neon-bounce/og-image-1200x630.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Neon Bounce - Free HTML5 Game">
<meta name="twitter:description" content="Play Neon Bounce - Tap to bounce a glowing ball between neon platforms. Miss a platform and fall into the void.">
<meta name="twitter:image" content="https://balinti.github.io/neon-bounce/og-image-1200x630.png">
<link rel="canonical" href="https://balinti.github.io/neon-bounce/">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0014;font-family:'Segoe UI',system-ui,sans-serif;touch-action:none;user-select:none;-webkit-user-select:none;-webkit-tap-highlight-color:transparent}
#wrap{display:flex;align-items:center;justify-content:center;flex-direction:column;width:100%;height:100%}
canvas{display:block;cursor:pointer;image-rendering:crisp-edges}
#safe-bottom{width:100%;max-width:420px;height:60px;flex-shrink:0;background:rgba(10,0,20,0.95)}
</style>
</head>
<body>
<div id="wrap">
<canvas id="c"></canvas>
<div id="safe-bottom"></div>
</div>
<script>
'use strict';
(()=>{

// ═══════════════════════════════════════════════════════════
//  CONSTANTS
// ═══════════════════════════════════════════════════════════
const VW=420,VH=750;
const LANE_X=[VW*0.25,VW*0.75];
const BALL_R=11;
const GRAVITY=1600;
const BOUNCE_VEL=-680;
const PLAT_H=12;
const PLAT_W_BASE=120,PLAT_W_MIN=62;
const EDGE_ZONE=14;
const SCROLL_BASE=140;
const GAP_MIN=110,GAP_MAX=170;
const DT_FIXED=1/120;
const DT_MAX_FRAME=0.1;
const MAX_PARTICLES=220;
const SHIELD_CHARGES=3;
const LS_KEY='nb_best';

// ═══════════════════════════════════════════════════════════
//  CANVAS + HiDPI
// ═══════════════════════════════════════════════════════════
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
let dpr,scale;

function resize(){
  const safeH=60;
  const maxW=420,maxH=750;
  let w=Math.min(window.innerWidth,maxW);
  let h=Math.min(window.innerHeight-safeH,maxH);
  const aspect=VW/VH;
  if(w/h>aspect)w=h*aspect;else h=w/aspect;
  dpr=Math.min(window.devicePixelRatio||1,2);
  canvas.width=Math.round(w*dpr);
  canvas.height=Math.round(h*dpr);
  canvas.style.width=w+'px';
  canvas.style.height=h+'px';
  scale=(w*dpr)/VW;
}
window.addEventListener('resize',resize);
resize();

// ═══════════════════════════════════════════════════════════
//  STATE
// ═══════════════════════════════════════════════════════════
let state='start';
let score=0,bestScore=0,combo=0,comboMult=1;
let shieldCharge=0,shieldReady=false;
let hueBase=200;
let scrollSpeed=SCROLL_BASE;
let accumulator=0,lastTime=0;
let diffT=0;
let shakeX=0,shakeY=0,shakeMag=0;
let phaseFlash=0;
let slowTimer=0,slowFactor=1;
let goFadeIn=0;

try{bestScore=parseInt(localStorage.getItem(LS_KEY))||0}catch(e){}

// ═══════════════════════════════════════════════════════════
//  OBJECTS
// ═══════════════════════════════════════════════════════════
const ball={x:0,y:0,vy:0,lane:0,trail:[]};
let platforms=[];
let particles=[];
let popups=[];

// ═══════════════════════════════════════════════════════════
//  HELPERS
// ═══════════════════════════════════════════════════════════
const hsl=(h,s,l,a)=>a!=null?`hsla(${h|0},${s}%,${l}%,${a})`:`hsl(${h|0},${s}%,${l}%)`;
const lerp=(a,b,t)=>a+(b-a)*t;
const rand=(a,b)=>a+Math.random()*(b-a);
const randInt=(a,b)=>Math.floor(rand(a,b+1));
const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;

function addShake(m){shakeMag=Math.max(shakeMag,m)}

function spawnParticles(x,y,n,hue,spd,spread){
  for(let i=0;i<n&&particles.length<MAX_PARTICLES;i++){
    const a=rand(0,Math.PI*2);
    const sp=rand(spd*0.3,spd);
    particles.push({
      x,y,
      vx:Math.cos(a)*sp+rand(-spread,spread),
      vy:Math.sin(a)*sp-rand(0,spd*0.4),
      life:1,decay:rand(1,2.8),
      r:rand(2,5),
      hue:hue+rand(-25,25),sat:rand(70,100),lit:rand(50,80)
    });
  }
}

function addPopup(x,y,text,hue){
  popups.push({x,y,text,hue,life:1,vy:-90});
}

// ═══════════════════════════════════════════════════════════
//  PLATFORM SPAWNING
// ═══════════════════════════════════════════════════════════
function platWidth(){
  const t=clamp(diffT/200,0,1);
  return lerp(PLAT_W_BASE,PLAT_W_MIN,t*0.75);
}

function spawnPlat(yy,forceLane){
  const lane=forceLane!=null?forceLane:randInt(0,1);
  const cx=LANE_X[lane];
  const w=clamp(platWidth()+rand(-10,10),PLAT_W_MIN,PLAT_W_BASE+20);
  const driftAmp=(diffT>25&&Math.random()<clamp(diffT/350,0,0.3))?rand(12,30)*(Math.random()<0.5?-1:1):0;
  platforms.push({
    x:cx,y:yy,w,lane,
    hue:hueBase+rand(-30,30),
    drift:driftAmp,driftBase:cx,
    hit:false,edgeHit:false
  });
}

function initPlatforms(){
  platforms=[];
  // Starting platform right under the ball
  platforms.push({
    x:ball.x,y:ball.y+55,w:PLAT_W_BASE+30,lane:ball.lane,
    hue:hueBase,drift:0,driftBase:ball.x,hit:false,edgeHit:false
  });
  let lastY=ball.y+55;
  for(let i=0;i<10;i++){
    lastY+=rand(GAP_MIN,GAP_MAX);
    spawnPlat(lastY);
  }
}

// ═══════════════════════════════════════════════════════════
//  RESET
// ═══════════════════════════════════════════════════════════
function resetGame(){
  ball.lane=0;ball.x=LANE_X[0];ball.y=VH*0.32;ball.vy=0;ball.trail=[];
  score=0;combo=0;comboMult=1;
  shieldCharge=0;shieldReady=false;
  scrollSpeed=SCROLL_BASE;diffT=0;
  particles=[];popups=[];
  shakeMag=0;shakeX=0;shakeY=0;
  phaseFlash=0;slowTimer=0;slowFactor=1;goFadeIn=0;
  hueBase=rand(0,360);
  initPlatforms();
}

// ═══════════════════════════════════════════════════════════
//  INPUT
// ═══════════════════════════════════════════════════════════
let inputQ=[];

function doShift(){
  if(state==='start'){
    state='playing';
    resetGame();
    ball.vy=BOUNCE_VEL;
    return;
  }
  if(state==='gameover'){
    state='start';
    return;
  }
  if(state==='playing'){
    ball.lane=1-ball.lane;
    ball.x=LANE_X[ball.lane];
    // Check if drift platforms moved the lane center - snap to lane
    phaseFlash=0.45;
    addShake(2.5);
    spawnParticles(ball.x,ball.y,7,hueBase+180,120,30);
  }
}

canvas.addEventListener('pointerdown',e=>{e.preventDefault();inputQ.push(1)});
document.addEventListener('keydown',e=>{
  if(e.code==='Space'||e.code==='Enter'){e.preventDefault();inputQ.push(1)}
});

// ═══════════════════════════════════════════════════════════
//  PHYSICS (fixed timestep)
// ═══════════════════════════════════════════════════════════
function physics(dt){
  if(state!=='playing')return;
  const eDt=dt*slowFactor;
  diffT+=eDt;

  // Speed ramp
  scrollSpeed=SCROLL_BASE+diffT*0.7;
  const capScroll=Math.min(scrollSpeed,380);
  const scrollAmt=capScroll*eDt;

  // Ball gravity + motion
  const prevY=ball.y;
  ball.vy+=GRAVITY*eDt;
  ball.y+=ball.vy*eDt;

  // Trail
  ball.trail.push({x:ball.x,y:ball.y,a:1});
  if(ball.trail.length>18)ball.trail.shift();
  for(const t of ball.trail)t.a-=eDt*3;

  // Scroll platforms UP (ball falls down, world moves up)
  for(const p of platforms){
    p.y-=scrollAmt;
    if(p.drift!==0){
      p.x=p.driftBase+Math.sin(diffT*1.4)*p.drift;
    }
  }

  // Landing collision (ball moving down)
  if(ball.vy>0){
    for(const p of platforms){
      if(p.hit)continue;
      const hw=p.w/2;
      const dx=ball.x-p.x;
      if(Math.abs(dx)<hw+BALL_R*0.4){
        if(prevY+BALL_R<=p.y+4&&ball.y+BALL_R>=p.y){
          // LAND
          ball.y=p.y-BALL_R;
          ball.vy=BOUNCE_VEL;
          p.hit=true;
          const absDx=Math.abs(dx);
          const innerEdge=hw-EDGE_ZONE;

          if(absDx>innerEdge&&absDx<=hw+BALL_R*0.5){
            // EDGE GRAZE
            p.edgeHit=true;
            combo++;
            comboMult=1+combo*0.5;
            const pts=Math.floor(15*comboMult);
            score+=pts;
            shieldCharge=Math.min(shieldCharge+1,SHIELD_CHARGES);
            if(shieldCharge>=SHIELD_CHARGES)shieldReady=true;
            addPopup(ball.x,ball.y-25,`EDGE +${pts}`,55);
            if(combo>1)addPopup(ball.x,ball.y-50,`x${comboMult.toFixed(1)}`,40);
            spawnParticles(ball.x,p.y,16,55,220,50);
            addShake(4.5);
          } else {
            // CENTER LAND
            const pts=10;
            score+=pts;
            combo=0;comboMult=1;
            addPopup(ball.x,ball.y-22,`+${pts}`,hueBase);
            spawnParticles(ball.x,p.y,8,hueBase,130,30);
            addShake(1.5);
          }
          hueBase=(hueBase+8)%360;
          break;
        }
      }
    }
  }

  // Fell below screen
  if(ball.y>VH+60){
    if(shieldReady){
      // SHIELD SAVE
      shieldReady=false;shieldCharge=0;
      combo=0;comboMult=1;
      // Find a visible platform to warp back to
      let savePlat=null;
      for(let i=platforms.length-1;i>=0;i--){
        const p=platforms[i];
        if(p.y>50&&p.y<VH-100){savePlat=p;break}
      }
      if(savePlat){
        ball.x=savePlat.x;ball.y=savePlat.y-BALL_R-8;ball.lane=savePlat.lane;
      } else {
        ball.x=LANE_X[ball.lane];ball.y=VH*0.35;
      }
      ball.vy=BOUNCE_VEL*0.85;
      slowTimer=0.45;slowFactor=0.25;
      addShake(12);
      spawnParticles(ball.x,ball.y,35,180,300,80);
      addPopup(ball.x,ball.y-30,'SHIELD!',180);
    } else {
      // GAME OVER
      state='gameover';goFadeIn=0;
      addShake(16);
      spawnParticles(ball.x,Math.min(ball.y,VH-20),45,0,280,100);
      if(score>bestScore){bestScore=score;try{localStorage.setItem(LS_KEY,String(bestScore))}catch(e){}}
    }
  }

  // Slow-mo decay
  if(slowTimer>0){
    slowTimer-=dt;
    if(slowTimer<=0){slowFactor=1;slowTimer=0}
  }

  // Cull off-screen platforms
  platforms=platforms.filter(p=>p.y>-60);

  // Spawn new below
  let lowestY=-Infinity;
  for(const p of platforms)if(p.y>lowestY)lowestY=p.y;
  while(lowestY<VH+250){
    const gap=rand(GAP_MIN,GAP_MAX);
    lowestY+=gap;
    // Pattern: alternating lane strings
    if(diffT>18&&Math.random()<0.13){
      const startLane=randInt(0,1);
      for(let j=0;j<randInt(2,4);j++){
        spawnPlat(lowestY+j*85,(startLane+j)%2);
      }
      lowestY+=4*85;
    } else {
      spawnPlat(lowestY);
    }
  }

  // Particles
  for(const p of particles){
    p.x+=p.vx*eDt;p.y+=p.vy*eDt;
    p.vy+=350*eDt;p.life-=p.decay*eDt;
  }
  particles=particles.filter(p=>p.life>0);

  // Popups
  for(const p of popups){
    p.y+=p.vy*eDt;p.life-=eDt*1.6;
  }
  popups=popups.filter(p=>p.life>0);

  // Shake decay
  if(shakeMag>0){
    shakeX=(Math.random()-0.5)*shakeMag*2;
    shakeY=(Math.random()-0.5)*shakeMag*2;
    shakeMag*=0.87;
    if(shakeMag<0.3){shakeMag=0;shakeX=0;shakeY=0}
  }

  // Phase flash decay
  if(phaseFlash>0)phaseFlash=Math.max(0,phaseFlash-eDt*2.5);
}

// ═══════════════════════════════════════════════════════════
//  RENDERING HELPERS
// ═══════════════════════════════════════════════════════════
function neonRect(x,y,w,h,hue,alpha){
  const a=alpha||1;
  // Outer glow
  ctx.strokeStyle=hsl(hue,100,80,a*0.15);
  ctx.lineWidth=8;
  ctx.strokeRect(x-w/2-4,y-4,w+8,h+8);
  // Mid glow
  ctx.strokeStyle=hsl(hue,100,65,a*0.4);
  ctx.lineWidth=3;
  ctx.strokeRect(x-w/2-1,y-1,w+2,h+2);
  // Fill
  ctx.fillStyle=hsl(hue,85,45,a*0.9);
  ctx.fillRect(x-w/2,y,w,h);
  // Top highlight
  ctx.fillStyle=hsl(hue,90,70,a*0.6);
  ctx.fillRect(x-w/2,y,w,2);
}

function neonCircle(x,y,r,hue,alpha){
  const a=alpha||1;
  // Outer glow
  ctx.beginPath();ctx.arc(x,y,r+6,0,Math.PI*2);
  ctx.strokeStyle=hsl(hue,100,80,a*0.12);
  ctx.lineWidth=6;ctx.stroke();
  // Mid glow
  ctx.beginPath();ctx.arc(x,y,r+2,0,Math.PI*2);
  ctx.strokeStyle=hsl(hue,100,75,a*0.5);
  ctx.lineWidth=3;ctx.stroke();
  // Fill
  ctx.beginPath();ctx.arc(x,y,r,0,Math.PI*2);
  ctx.fillStyle=hsl(hue,85,65,a);
  ctx.fill();
}

// ═══════════════════════════════════════════════════════════
//  RENDER
// ═══════════════════════════════════════════════════════════
function render(dt){
  ctx.save();
  ctx.setTransform(scale,0,0,scale,0,0);
  ctx.translate(shakeX,shakeY);

  // ── Background gradient ──
  const grad=ctx.createLinearGradient(0,0,0,VH);
  grad.addColorStop(0,'#080016');
  grad.addColorStop(0.5,'#0c001e');
  grad.addColorStop(1,'#050010');
  ctx.fillStyle=grad;
  ctx.fillRect(-30,-30,VW+60,VH+60);

  // Phase flash
  if(phaseFlash>0){
    ctx.fillStyle=hsl((hueBase+180)%360,80,55,phaseFlash*0.12);
    ctx.fillRect(0,0,VW,VH);
  }

  // ── Lane divider ──
  ctx.save();
  ctx.setLineDash([6,10]);
  ctx.strokeStyle=hsl(hueBase,25,35,0.12);
  ctx.lineWidth=1;
  ctx.beginPath();ctx.moveTo(VW/2,0);ctx.lineTo(VW/2,VH);ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();

  // ── Tunnel walls ──
  const wa=0.1;
  ctx.strokeStyle=hsl(hueBase+90,50,50,wa);
  ctx.lineWidth=2;
  ctx.beginPath();ctx.moveTo(8,0);ctx.lineTo(8,VH);ctx.stroke();
  ctx.beginPath();ctx.moveTo(VW-8,0);ctx.lineTo(VW-8,VH);ctx.stroke();

  // ── Platforms ──
  for(const p of platforms){
    if(p.y<-40||p.y>VH+40)continue;
    const alpha=p.hit?0.35:1;
    const ph=p.edgeHit?55:p.hue;
    const hw=p.w/2;
    const inner=hw-EDGE_ZONE;

    neonRect(p.x,p.y,p.w,PLAT_H,ph,alpha);

    // Edge zone highlights
    if(!p.hit){
      ctx.fillStyle=hsl(55,100,65,0.22);
      ctx.fillRect(p.x-hw,p.y,EDGE_ZONE,PLAT_H);
      ctx.fillRect(p.x+inner,p.y,EDGE_ZONE,PLAT_H);
      // Thin bright edge lines
      ctx.fillStyle=hsl(55,100,80,0.35);
      ctx.fillRect(p.x-hw,p.y,2,PLAT_H);
      ctx.fillRect(p.x+hw-2,p.y,2,PLAT_H);
    }
  }

  // ── Ball trail ──
  ctx.globalCompositeOperation='lighter';
  for(let i=0;i<ball.trail.length;i++){
    const t=ball.trail[i];
    if(t.a<=0)continue;
    const r=BALL_R*(t.a*0.55);
    ctx.beginPath();ctx.arc(t.x,t.y,r,0,Math.PI*2);
    ctx.fillStyle=hsl(hueBase,80,55,t.a*0.25);
    ctx.fill();
  }
  ctx.globalCompositeOperation='source-over';

  // ── Ball ──
  if(state!=='gameover'){
    neonCircle(ball.x,ball.y,BALL_R,hueBase,1);
    // Inner core
    ctx.beginPath();ctx.arc(ball.x,ball.y,BALL_R*0.35,0,Math.PI*2);
    ctx.fillStyle=hsl(hueBase,50,92,0.9);
    ctx.fill();
    // Shield ring
    if(shieldReady){
      ctx.beginPath();ctx.arc(ball.x,ball.y,BALL_R+8,0,Math.PI*2);
      ctx.strokeStyle=hsl(180,100,70,0.55+Math.sin(Date.now()*0.008)*0.2);
      ctx.lineWidth=2;ctx.stroke();
    }
  }

  // ── Particles (lighter) ──
  ctx.globalCompositeOperation='lighter';
  for(const p of particles){
    if(p.life<=0)continue;
    ctx.beginPath();ctx.arc(p.x,p.y,p.r*p.life,0,Math.PI*2);
    ctx.fillStyle=hsl(p.hue,p.sat,p.lit,p.life*0.75);
    ctx.fill();
  }
  ctx.globalCompositeOperation='source-over';

  // ── Popups ──
  ctx.textAlign='center';
  for(const p of popups){
    if(p.life<=0)continue;
    const sz=13+p.life*5|0;
    ctx.font=`bold ${sz}px 'Segoe UI',system-ui,sans-serif`;
    ctx.fillStyle=hsl(p.hue,90,75,p.life);
    ctx.fillText(p.text,p.x,p.y);
  }

  // ═══════ HUD ═══════
  ctx.textAlign='left';
  ctx.font="bold 24px 'Segoe UI',system-ui,sans-serif";
  ctx.fillStyle=hsl(hueBase,55,85,0.9);
  ctx.fillText(String(score),20,38);

  ctx.font="11px 'Segoe UI',system-ui,sans-serif";
  ctx.fillStyle=hsl(hueBase,35,60,0.55);
  ctx.fillText(`BEST ${bestScore}`,20,54);

  // Combo
  if(combo>0&&state==='playing'){
    ctx.textAlign='right';
    ctx.font="bold 15px 'Segoe UI',system-ui,sans-serif";
    ctx.fillStyle=hsl(40,90,68,0.9);
    ctx.fillText(`COMBO x${comboMult.toFixed(1)}`,VW-18,36);

    ctx.font="11px 'Segoe UI',system-ui,sans-serif";
    ctx.fillStyle=hsl(40,70,55,0.5);
    ctx.fillText(`streak ${combo}`,VW-18,52);
  }

  // Shield meter
  if(state==='playing'){
    const mW=55,mH=5,mx=VW-18-mW,my=60;
    ctx.fillStyle='rgba(255,255,255,0.07)';
    ctx.fillRect(mx,my,mW,mH);
    const fill=shieldReady?1:(shieldCharge/SHIELD_CHARGES);
    const sHue=shieldReady?175:210;
    ctx.fillStyle=hsl(sHue,80,shieldReady?65:38,0.8);
    ctx.fillRect(mx,my,mW*fill,mH);
    ctx.textAlign='right';
    ctx.font="8px 'Segoe UI',system-ui,sans-serif";
    ctx.fillStyle=hsl(sHue,50,65,0.5);
    ctx.fillText(shieldReady?'SHIELD READY':'SHIELD',VW-18,my+mH+10);
  }

  // ═══════ START SCREEN ═══════
  if(state==='start'){
    ctx.fillStyle='rgba(8,0,18,0.55)';
    ctx.fillRect(0,0,VW,VH);

    ctx.textAlign='center';

    ctx.font="bold 44px 'Segoe UI',system-ui,sans-serif";
    ctx.fillStyle=hsl(hueBase,90,78,0.95);
    ctx.fillText('NEON',VW/2,VH*0.26);
    ctx.fillStyle=hsl((hueBase+55)%360,90,72,0.95);
    ctx.fillText('BOUNCE',VW/2,VH*0.26+48);

    ctx.font="13px 'Segoe UI',system-ui,sans-serif";
    ctx.fillStyle=hsl((hueBase+25)%360,45,62,0.65);
    ctx.fillText('Split-Beat',VW/2,VH*0.26+72);

    ctx.font="15px 'Segoe UI',system-ui,sans-serif";
    ctx.fillStyle='rgba(255,255,255,0.55)';
    ctx.fillText('Tap / Space / Enter',VW/2,VH*0.50);
    ctx.fillText('to phase-shift between lanes',VW/2,VH*0.50+22);

    ctx.font="12px 'Segoe UI',system-ui,sans-serif";
    ctx.fillStyle=hsl(55,65,62,0.45);
    ctx.fillText('Graze platform edges for bonus',VW/2,VH*0.62);
    ctx.fillText('points & charge your Neon Shield',VW/2,VH*0.62+18);

    const pulse=0.4+Math.sin(Date.now()*0.004)*0.45;
    ctx.font="bold 20px 'Segoe UI',system-ui,sans-serif";
    ctx.fillStyle=hsl(hueBase,80,78,pulse);
    ctx.fillText('TAP TO START',VW/2,VH*0.78);

    if(bestScore>0){
      ctx.font="13px 'Segoe UI',system-ui,sans-serif";
      ctx.fillStyle=hsl(hueBase,35,60,0.45);
      ctx.fillText(`Best: ${bestScore}`,VW/2,VH*0.78+28);
    }
  }

  // ═══════ GAME OVER SCREEN ═══════
  if(state==='gameover'){
    goFadeIn=Math.min(goFadeIn+(dt||0.016)*2,1);
    ctx.fillStyle=`rgba(8,0,18,${goFadeIn*0.7})`;
    ctx.fillRect(0,0,VW,VH);

    ctx.textAlign='center';
    const oa=goFadeIn;

    ctx.font="bold 40px 'Segoe UI',system-ui,sans-serif";
    ctx.fillStyle=hsl(0,80,62,oa*0.95);
    ctx.fillText('GAME OVER',VW/2,VH*0.30);

    ctx.font="bold 54px 'Segoe UI',system-ui,sans-serif";
    ctx.fillStyle=hsl(hueBase,80,78,oa*0.95);
    ctx.fillText(String(score),VW/2,VH*0.43);

    ctx.font="13px 'Segoe UI',system-ui,sans-serif";
    ctx.fillStyle=`rgba(255,255,255,${oa*0.45})`;
    ctx.fillText('SCORE',VW/2,VH*0.43+22);

    if(score>=bestScore&&score>0){
      ctx.font="bold 17px 'Segoe UI',system-ui,sans-serif";
      ctx.fillStyle=hsl(50,90,68,oa*0.9);
      ctx.fillText('NEW BEST!',VW/2,VH*0.53);
    } else {
      ctx.font="13px 'Segoe UI',system-ui,sans-serif";
      ctx.fillStyle=hsl(hueBase,35,60,oa*0.45);
      ctx.fillText(`Best: ${bestScore}`,VW/2,VH*0.53);
    }

    const pulse2=0.35+Math.sin(Date.now()*0.003)*0.4;
    ctx.font="bold 18px 'Segoe UI',system-ui,sans-serif";
    ctx.fillStyle=hsl(hueBase,70,72,oa*pulse2);
    ctx.fillText('TAP TO CONTINUE',VW/2,VH*0.72);
  }

  ctx.restore();
}

// ═══════════════════════════════════════════════════════════
//  MAIN LOOP
// ═══════════════════════════════════════════════════════════
function loop(time){
  requestAnimationFrame(loop);
  if(!lastTime){lastTime=time;return}
  let dt=(time-lastTime)/1000;
  lastTime=time;
  if(dt>DT_MAX_FRAME)dt=DT_MAX_FRAME;

  // Hue cycle
  hueBase=(hueBase+dt*14)%360;

  // Process input
  while(inputQ.length){inputQ.shift();doShift()}

  // Fixed-step physics
  if(state==='playing'){
    accumulator+=dt;
    let steps=0;
    while(accumulator>=DT_FIXED&&steps<12){
      physics(DT_FIXED);
      accumulator-=DT_FIXED;
      steps++;
    }
  } else {
    // Decay particles/shake even outside gameplay
    if(shakeMag>0){
      shakeX=(Math.random()-0.5)*shakeMag*2;
      shakeY=(Math.random()-0.5)*shakeMag*2;
      shakeMag*=0.9;
      if(shakeMag<0.3){shakeMag=0;shakeX=0;shakeY=0}
    }
    for(const p of particles){
      p.x+=p.vx*dt;p.y+=p.vy*dt;p.vy+=350*dt;p.life-=p.decay*dt;
    }
    particles=particles.filter(p=>p.life>0);
    for(const p of popups){p.y+=p.vy*dt;p.life-=dt*1.6}
    popups=popups.filter(p=>p.life>0);
  }

  render(dt);
}

// ── Init ──
resetGame();
state='start';
requestAnimationFrame(loop);

})();
</script>
</body>
</html>
