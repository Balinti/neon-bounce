<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Neon Bounce - Free HTML5 Game</title>
<meta name="description" content="Play Neon Bounce - Tap to bounce a glowing ball between neon platforms. Miss a platform and fall into the void. Platforms get narrower as score increases.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0b0f1a">
<meta property="og:type" content="website">
<meta property="og:title" content="Neon Bounce - Free HTML5 Game">
<meta property="og:description" content="Tap to bounce a glowing ball between neon platforms. Miss a platform and fall into the void!">
<meta property="og:url" content="https://balinti.github.io/neon-bounce/">
<meta property="og:image" content="https://balinti.github.io/neon-bounce/og.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Neon Bounce - Free HTML5 Game">
<meta name="twitter:description" content="Tap to bounce a glowing ball between neon platforms. Miss a platform and fall into the void!">
<meta name="twitter:image" content="https://balinti.github.io/neon-bounce/og.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0b0f1a;font-family:'Segoe UI',system-ui,sans-serif;touch-action:none;user-select:none;-webkit-user-select:none}
#wrap{display:flex;flex-direction:column;align-items:center;justify-content:flex-start;width:100%;height:100%;position:relative;overflow-y:auto}
#c{display:block;max-width:420px;max-height:750px;width:100%;flex-shrink:0}
#info{max-width:420px;width:100%;color:#8892a4;font-size:12px;padding:14px 12px 32px;line-height:1.6;text-align:center}
#info h3{color:#c8d0e0;font-size:14px;margin:10px 0 4px}
#info p{margin:0 0 6px}
</style>
</head>
<body>
<div id="wrap">
<canvas id="c"></canvas>
<div id="info">
<h3>How to Play</h3>
<p>Tap or press Space to bounce and switch lanes. Land on platform centers for combo bonuses. Collect shards to fill the Overdrive meter for a score multiplier boost!</p>
<h3>FAQ</h3>
<p><strong>Is Neon Bounce free?</strong> Yes, Neon Bounce is 100% free to play in any browser.</p>
<p><strong>How do I get a high score?</strong> Hit platform hot zones for combos, collect shards, and activate Overdrive for maximum points.</p>
<p><strong>Does it work on mobile?</strong> Yes! Tap anywhere on the screen to play.</p>
</div>
</div>
<script>
(function(){
"use strict";

const cv=document.getElementById("c");
const ctx=cv.getContext("2d");

/* ======== Hi-DPI scaling ======== */
let DPR=Math.min(window.devicePixelRatio||1,3);
let W,H;
function resize(){
  const maxW=420,maxH=750;
  let cw=Math.min(window.innerWidth,maxW);
  let ch=Math.min(window.innerHeight,maxH);
  if(window.innerWidth<=520) ch=Math.min(window.innerHeight,maxH);
  DPR=Math.min(window.devicePixelRatio||1,3);
  cv.style.width=cw+"px";
  cv.style.height=ch+"px";
  cv.width=Math.round(cw*DPR);
  cv.height=Math.round(ch*DPR);
  W=cw; H=ch;
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
resize();
window.addEventListener("resize",resize);

/* ======== Constants ======== */
const LANE_L=()=>W*0.28;
const LANE_R=()=>W*0.72;
const BALL_R=10;
const GRAVITY=0.38;
const BASE_SCROLL=1.8;
const BASE_SPAWN=88;
const BASE_PLAT_W=72;
const MIN_PLAT_W=36;
const PLAT_H=10;
const HOT_ZONE_RATIO=0.30;
const JUMP_V=-9.5;
const COLLISION_INSET=4;
const OVERDRIVE_DURATION=180;
const MAX_PARTICLES=240;
const SHARD_SIZE=8;
const SHARD_SPAWN_CHANCE=0.18;
const OVERDRIVE_FILL=100;

/* ======== State ======== */
let state="start";
let score=0;
let best=parseInt(localStorage.getItem("nb_best2"))||0;
let combo=0;
let overdriveTimer=0;
let overdriveMeter=0;
let hue=200;
let shakeT=0;
let shakeIntensity=0;
let frameCount=0;

/* ======== Challenge params ======== */
const urlParams=new URLSearchParams(window.location.search);
const challengeTarget=urlParams.get("target")?parseInt(urlParams.get("target")):null;
const challengeCode=urlParams.get("challenge")||null;

/* ======== Ball ======== */
let ball={x:0,y:0,vx:0,vy:0,lane:0,onPlat:false,trail:[]};

/* ======== Platforms / Shards ======== */
let platforms=[];
let shards=[];

/* ======== Particle pool ======== */
let particles=[];

function spawnParticles(x,y,count,color,speed,life){
  for(let i=0;i<count&&particles.length<MAX_PARTICLES;i++){
    const a=Math.random()*Math.PI*2;
    const s=(0.5+Math.random()*1.5)*speed;
    particles.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life,maxLife:life,color,size:2+Math.random()*3});
  }
}

function updateParticles(){
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x+=p.vx; p.y+=p.vy;
    p.vy+=0.04;
    p.life--;
    if(p.life<=0) particles.splice(i,1);
  }
}

function drawParticles(){
  for(const p of particles){
    const a=p.life/p.maxLife;
    ctx.globalAlpha=a;
    ctx.fillStyle=p.color;
    ctx.fillRect(p.x-p.size*a/2,p.y-p.size*a/2,p.size*a,p.size*a);
  }
  ctx.globalAlpha=1;
}

/* ======== Difficulty scaling ======== */
function diff(){
  const t=Math.min(score,250);
  return{
    scrollV: BASE_SCROLL+t*0.012,
    spawnInterval: Math.max(32, BASE_SPAWN-t*0.22),
    platW: Math.max(MIN_PLAT_W, BASE_PLAT_W-t*0.15),
    jumpV: JUMP_V-t*0.005,
    moverChance: Math.min(0.35, 0.02+t*0.0015),
    breakableChance: Math.min(0.18, t*0.0008),
    fakeChance: Math.min(0.10, t*0.0005)
  };
}

/* ======== Platform spawn ======== */
let spawnTimer=0;
function spawnRow(){
  const d=diff();
  const pw=d.platW+(overdriveTimer>0?14:0);
  const hotW=pw*HOT_ZONE_RATIO;
  for(let lane=0;lane<2;lane++){
    const cx=lane===0?LANE_L():LANE_R();
    let type="normal";
    const r=Math.random();
    if(r<d.fakeChance) type="fake";
    else if(r<d.fakeChance+d.breakableChance) type="breakable";
    const isMover=Math.random()<d.moverChance&&type==="normal";
    platforms.push({
      x:cx-pw/2, y:-PLAT_H-10,
      w:pw, h:PLAT_H,
      hotX:cx-hotW/2, hotW:hotW,
      lane:lane, type:type,
      isMover:isMover,
      moveDir:Math.random()<0.5?1:-1,
      moveSpeed:0.4+Math.random()*0.6,
      moveRange:12+Math.random()*18,
      origX:cx-pw/2,
      broken:false, fakeReveal:false,
      hue:180+Math.random()*80
    });
  }
  if(Math.random()<SHARD_SPAWN_CHANCE){
    const lane=Math.random()<0.5?0:1;
    const cx=lane===0?LANE_L():LANE_R();
    shards.push({x:cx,y:-20,lane:lane,collected:false});
  }
}

/* ======== Screen shake ======== */
function triggerShake(intensity,duration){
  shakeIntensity=Math.max(shakeIntensity,intensity);
  shakeT=Math.max(shakeT,duration);
}

/* ======== Init ======== */
function initGame(){
  score=0; combo=0;
  overdriveTimer=0; overdriveMeter=0;
  frameCount=0; spawnTimer=0;
  shakeT=0; shakeIntensity=0;
  platforms=[]; shards=[]; particles=[];
  ball.lane=0;
  ball.x=LANE_L();
  ball.y=H*0.55;
  ball.vy=0;
  ball.onPlat=false;
  ball.trail=[];
  // initial platforms
  for(let i=0;i<8;i++){
    const pw=BASE_PLAT_W;
    const hotW=pw*HOT_ZONE_RATIO;
    for(let lane=0;lane<2;lane++){
      const cx=lane===0?LANE_L():LANE_R();
      platforms.push({
        x:cx-pw/2, y:H*0.35+i*65,
        w:pw, h:PLAT_H,
        hotX:cx-hotW/2, hotW:hotW,
        lane:lane, type:"normal",
        isMover:false, moveDir:1, moveSpeed:0, moveRange:0, origX:cx-pw/2,
        broken:false, fakeReveal:false,
        hue:180+Math.random()*80
      });
    }
  }
}

/* ======== Input ======== */
let inputLocked=false;
function doAction(){
  if(inputLocked) return;
  if(state==="start"){
    state="playing";
    initGame();
    ball.vy=JUMP_V;
    ball.onPlat=false;
    return;
  }
  if(state==="gameover"){
    // Short delay to prevent accidental restart
    return;
  }
  if(state==="playing"){
    ball.lane=ball.lane===0?1:0;
    ball.x=ball.lane===0?LANE_L():LANE_R();
    const d=diff();
    ball.vy=d.jumpV;
    ball.onPlat=false;
    spawnParticles(ball.x,ball.y,6,`hsl(${hue},100%,70%)`,2,25);
  }
}

let gameOverDelay=0;
cv.addEventListener("pointerdown",function(e){
  e.preventDefault();
  if(state==="gameover"){
    // Check share button first
    const rect=cv.getBoundingClientRect();
    const mx=(e.clientX-rect.left)*(W/rect.width);
    const my=(e.clientY-rect.top)*(H/rect.height);
    if(mx>=shareBtn.x&&mx<=shareBtn.x+shareBtn.w&&my>=shareBtn.y&&my<=shareBtn.y+shareBtn.h){
      shareChallenge();
      return;
    }
    if(gameOverDelay<=0){
      state="start";
    }
    return;
  }
  doAction();
});

document.addEventListener("keydown",function(e){
  if(e.code==="Space"||e.code==="Enter"){
    e.preventDefault();
    if(state==="gameover"&&gameOverDelay<=0){
      state="start";
      return;
    }
    doAction();
  }
});

/* ======== Share button ======== */
const shareBtn={x:0,y:0,w:0,h:0};
let copiedMsg=0;

function shareChallenge(){
  const code=Date.now().toString(36);
  const url="https://balinti.github.io/neon-bounce/?target="+score+"&challenge="+code;
  const text="I scored "+score+" in Neon Bounce! Can you beat me?\n"+url;
  if(navigator.share){
    navigator.share({title:"Neon Bounce Challenge",text:text,url:url}).catch(function(){});
  } else if(navigator.clipboard){
    navigator.clipboard.writeText(text).then(function(){copiedMsg=120;}).catch(function(){});
  }
}

/* ======== Update ======== */
function update(){
  if(state!=="playing"){
    if(state==="gameover"&&gameOverDelay>0) gameOverDelay--;
    updateParticles();
    return;
  }
  frameCount++;
  hue=(hue+0.5)%360;

  const d=diff();
  const sv=d.scrollV;

  // Gravity
  ball.vy+=GRAVITY;
  ball.y+=ball.vy;

  // Trail
  ball.trail.push({x:ball.x,y:ball.y});
  if(ball.trail.length>12) ball.trail.shift();

  // Move platforms down
  for(let i=0;i<platforms.length;i++){
    const p=platforms[i];
    p.y+=sv;
    if(p.isMover&&!p.broken){
      p.x=p.origX+Math.sin(frameCount*0.03*p.moveSpeed)*p.moveRange*p.moveDir;
      p.hotX=p.x+(p.w-p.hotW)/2;
    }
  }

  // Move shards down
  for(let i=0;i<shards.length;i++){
    shards[i].y+=sv;
  }

  // Spawn
  spawnTimer++;
  if(spawnTimer>=d.spawnInterval){
    spawnTimer=0;
    spawnRow();
  }

  // Collision (only when falling)
  if(ball.vy>=0){
    const bx=ball.x;
    const byBottom=ball.y+BALL_R;
    const prevByBottom=byBottom-ball.vy;
    for(let i=0;i<platforms.length;i++){
      const p=platforms[i];
      if(p.broken||p.y>H||p.y<-30) continue;
      // From-above check: prev frame ball bottom was above platform top, now at or below
      if(prevByBottom<=p.y+2 && byBottom>=p.y){
        if(bx>=p.x+COLLISION_INSET && bx<=p.x+p.w-COLLISION_INSET){
          // Hit platform
          if(p.type==="fake"){
            p.fakeReveal=true;
            p.broken=true;
            spawnParticles(bx,p.y,10,"#ff4466",2,30);
            continue;
          }
          if(p.type==="breakable"){
            p.broken=true;
            spawnParticles(p.x+p.w/2,p.y,15,`hsl(${p.hue},80%,60%)`,2.5,35);
          }
          // Snap to platform
          ball.y=p.y-BALL_R;
          ball.vy=0;
          ball.onPlat=true;

          // Scoring
          const hotHit=(bx>=p.hotX && bx<=p.hotX+p.hotW);
          let pts=1;
          if(hotHit){
            combo++;
            pts+=combo;
            overdriveMeter=Math.min(OVERDRIVE_FILL,overdriveMeter+5+combo*2);
            spawnParticles(bx,p.y,12,`hsl(${hue},100%,80%)`,3,30);
            triggerShake(2,8);
          } else {
            combo=0;
          }
          // Near-miss bonus
          const edgeDistL=Math.abs(bx-(p.x+COLLISION_INSET));
          const edgeDistR=Math.abs(bx-(p.x+p.w-COLLISION_INSET));
          const edgeDist=Math.min(edgeDistL,edgeDistR);
          if(edgeDist<8){
            pts+=3;
            spawnParticles(bx,p.y,8,"#ffffff",2,20);
          }
          // Overdrive multiplier
          if(overdriveTimer>0) pts*=3;
          score+=pts;
          if(score>best){
            best=score;
            localStorage.setItem("nb_best2",String(best));
          }
          spawnParticles(bx,p.y,4,`hsl(${p.hue},90%,65%)`,1.5,20);
          break;
        }
      }
    }
  }

  // Shard collection
  for(let i=shards.length-1;i>=0;i--){
    const s=shards[i];
    if(s.collected) continue;
    const dx=ball.x-s.x, dy=ball.y-s.y;
    if(dx*dx+dy*dy<(BALL_R+SHARD_SIZE)*(BALL_R+SHARD_SIZE)){
      s.collected=true;
      score+=5;
      overdriveMeter=Math.min(OVERDRIVE_FILL,overdriveMeter+15);
      spawnParticles(s.x,s.y,18,`hsl(${(hue+120)%360},100%,75%)`,3,35);
      triggerShake(1.5,5);
      if(score>best){best=score;localStorage.setItem("nb_best2",String(best));}
    }
  }

  // Overdrive trigger
  if(overdriveMeter>=OVERDRIVE_FILL&&overdriveTimer<=0){
    overdriveTimer=OVERDRIVE_DURATION;
    overdriveMeter=0;
    spawnParticles(ball.x,ball.y,30,`hsl(${hue},100%,90%)`,4,45);
    triggerShake(4,12);
  }
  if(overdriveTimer>0) overdriveTimer--;

  // Cleanup
  platforms=platforms.filter(function(p){return p.y<H+60;});
  shards=shards.filter(function(s){return s.y<H+60&&!s.collected;});

  // Fall death
  if(ball.y-BALL_R>H+30){
    state="gameover";
    gameOverDelay=40;
    triggerShake(10,35);
    spawnParticles(ball.x,H-40,45,`hsl(${hue},100%,60%)`,4.5,55);
  }

  // Shake decay
  if(shakeT>0) shakeT--;

  updateParticles();
}

/* ======== Draw ======== */
function roundRect(x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.lineTo(x+w-r,y);
  ctx.quadraticCurveTo(x+w,y,x+w,y+r);
  ctx.lineTo(x+w,y+h-r);
  ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  ctx.lineTo(x+r,y+h);
  ctx.quadraticCurveTo(x,y+h,x,y+h-r);
  ctx.lineTo(x,y+r);
  ctx.quadraticCurveTo(x,y,x+r,y);
  ctx.closePath();
}

function draw(){
  ctx.save();

  // Screen shake offset
  if(shakeT>0){
    const mag=shakeIntensity*(shakeT/35);
    ctx.translate((Math.random()-0.5)*mag*2,(Math.random()-0.5)*mag*2);
  }

  // Background gradient
  const bg=ctx.createLinearGradient(0,0,0,H);
  bg.addColorStop(0,"#0b0f1a");
  bg.addColorStop(0.5,"#10152a");
  bg.addColorStop(1,"#141828");
  ctx.fillStyle=bg;
  ctx.fillRect(-15,-15,W+30,H+30);

  // Subtle grid lines
  ctx.strokeStyle="rgba(80,100,160,0.06)";
  ctx.lineWidth=1;
  for(let gy=((frameCount*0.5)%40);gy<H;gy+=40){
    ctx.beginPath();ctx.moveTo(0,gy);ctx.lineTo(W,gy);ctx.stroke();
  }

  // Lane guides
  ctx.strokeStyle="rgba(100,130,200,0.1)";
  ctx.setLineDash([4,8]);
  ctx.beginPath();ctx.moveTo(LANE_L(),0);ctx.lineTo(LANE_L(),H);ctx.stroke();
  ctx.beginPath();ctx.moveTo(LANE_R(),0);ctx.lineTo(LANE_R(),H);ctx.stroke();
  ctx.setLineDash([]);

  if(state==="start"){
    drawStartScreen();
    ctx.restore();
    return;
  }

  drawGame();

  if(state==="gameover"){
    drawGameOver();
  }

  // Copied msg
  if(copiedMsg>0){
    const ca=Math.min(1,copiedMsg/40);
    ctx.globalAlpha=ca;
    ctx.fillStyle="#44dd88";
    ctx.font="bold 14px 'Segoe UI',system-ui,sans-serif";
    ctx.textAlign="center";
    ctx.fillText("Link copied!",W/2,H*0.88);
    ctx.globalAlpha=1;
    copiedMsg--;
  }

  ctx.restore();
}

function drawGame(){
  // Platforms
  for(let i=0;i<platforms.length;i++){
    const p=platforms[i];
    if(p.broken||p.fakeReveal) continue;
    if(p.y<-20||p.y>H+20) continue;

    ctx.save();
    if(p.type==="fake"){
      // Looks normal but slightly transparent
      ctx.globalAlpha=0.55;
    }

    if(p.type==="breakable"){
      ctx.strokeStyle=`hsl(${p.hue},70%,55%)`;
      ctx.lineWidth=2;
      ctx.setLineDash([4,3]);
      ctx.strokeRect(p.x,p.y,p.w,p.h);
      ctx.setLineDash([]);
      // Faint fill
      ctx.fillStyle=`hsla(${p.hue},60%,40%,0.15)`;
      ctx.fillRect(p.x,p.y,p.w,p.h);
    } else {
      // Normal / fake platform
      const g=ctx.createLinearGradient(p.x,p.y,p.x+p.w,p.y);
      g.addColorStop(0,`hsl(${p.hue},75%,48%)`);
      g.addColorStop(1,`hsl(${(p.hue+25)%360},75%,58%)`);
      ctx.fillStyle=g;
      roundRect(p.x,p.y,p.w,p.h,4);
      ctx.fill();

      // Hot zone highlight
      ctx.fillStyle=`hsla(${p.hue},100%,82%,0.3)`;
      ctx.fillRect(p.hotX,p.y+1,p.hotW,p.h-2);
    }

    // Glow
    ctx.shadowColor=`hsl(${p.hue},100%,60%)`;
    ctx.shadowBlur=10;
    ctx.globalAlpha=0.12;
    ctx.fillStyle=`hsl(${p.hue},100%,60%)`;
    ctx.fillRect(p.x,p.y-2,p.w,p.h+4);
    ctx.shadowBlur=0;
    ctx.restore();
  }

  // Shards
  for(let i=0;i<shards.length;i++){
    const s=shards[i];
    if(s.collected||s.y<-20||s.y>H+20) continue;
    ctx.save();
    ctx.translate(s.x,s.y);
    ctx.rotate(frameCount*0.05);
    const sh=(hue+120)%360;
    ctx.fillStyle=`hsl(${sh},100%,70%)`;
    ctx.shadowColor=`hsl(${sh},100%,80%)`;
    ctx.shadowBlur=12;
    ctx.beginPath();
    ctx.moveTo(0,-SHARD_SIZE);
    ctx.lineTo(SHARD_SIZE*0.6,0);
    ctx.lineTo(0,SHARD_SIZE);
    ctx.lineTo(-SHARD_SIZE*0.6,0);
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur=0;
    ctx.restore();
  }

  // Particles
  drawParticles();

  // Ball trail
  for(let i=0;i<ball.trail.length;i++){
    const t=ball.trail[i];
    const a=(i/ball.trail.length)*0.3;
    const s=BALL_R*(i/ball.trail.length);
    ctx.beginPath();
    ctx.arc(t.x,t.y,s,0,Math.PI*2);
    ctx.fillStyle=`hsla(${hue},100%,70%,${a})`;
    ctx.fill();
  }

  // Ball
  ctx.save();
  if(overdriveTimer>0){
    // Chromatic aberration split
    ctx.globalAlpha=0.35;
    ctx.beginPath();ctx.arc(ball.x-3,ball.y-1,BALL_R+1,0,Math.PI*2);
    ctx.fillStyle=`hsl(${(hue+70)%360},100%,65%)`;ctx.fill();
    ctx.beginPath();ctx.arc(ball.x+3,ball.y+1,BALL_R+1,0,Math.PI*2);
    ctx.fillStyle=`hsl(${(hue-70+360)%360},100%,65%)`;ctx.fill();
    ctx.globalAlpha=1;
  }
  ctx.beginPath();
  ctx.arc(ball.x,ball.y,BALL_R,0,Math.PI*2);
  const bGrad=ctx.createRadialGradient(ball.x-2,ball.y-2,1,ball.x,ball.y,BALL_R);
  bGrad.addColorStop(0,`hsl(${hue},100%,92%)`);
  bGrad.addColorStop(1,`hsl(${hue},100%,58%)`);
  ctx.fillStyle=bGrad;
  ctx.shadowColor=`hsl(${hue},100%,70%)`;
  ctx.shadowBlur=18;
  ctx.fill();
  ctx.shadowBlur=0;
  ctx.restore();

  // ---- HUD ----
  // Score top-left
  ctx.fillStyle="#fff";
  ctx.font="bold 24px 'Segoe UI',system-ui,sans-serif";
  ctx.textAlign="left";
  ctx.textBaseline="top";
  ctx.fillText(String(score),14,10);

  // Best top-right
  ctx.fillStyle="#6a7490";
  ctx.font="13px 'Segoe UI',system-ui,sans-serif";
  ctx.textAlign="right";
  ctx.fillText("BEST "+best,W-12,14);

  // Combo top-center
  if(combo>1){
    ctx.fillStyle=`hsl(${hue},100%,75%)`;
    ctx.font="bold 16px 'Segoe UI',system-ui,sans-serif";
    ctx.textAlign="center";
    ctx.fillText("x"+combo,W/2,12);
  }

  // Overdrive meter
  const mW=80, mH=5, mX=W/2-mW/2, mY=34;
  ctx.fillStyle="rgba(255,255,255,0.08)";
  roundRect(mX,mY,mW,mH,2);ctx.fill();
  const fillR=overdriveTimer>0?(overdriveTimer/OVERDRIVE_DURATION):(overdriveMeter/OVERDRIVE_FILL);
  if(fillR>0){
    const mc=overdriveTimer>0?`hsl(${hue},100%,68%)`:`hsl(${(hue+60)%360},80%,50%)`;
    ctx.fillStyle=mc;
    roundRect(mX,mY,mW*fillR,mH,2);ctx.fill();
  }
  if(overdriveTimer>0){
    const pulse=0.6+Math.sin(frameCount*0.25)*0.3;
    ctx.globalAlpha=pulse;
    ctx.fillStyle=`hsl(${hue},100%,80%)`;
    ctx.font="bold 9px 'Segoe UI',system-ui,sans-serif";
    ctx.textAlign="center";
    ctx.textBaseline="top";
    ctx.fillText("OVERDRIVE",W/2,mY+mH+3);
    ctx.globalAlpha=1;
  }
  ctx.textBaseline="alphabetic";
}

function drawStartScreen(){
  // Animated background particles
  if(Math.random()<0.15){
    spawnParticles(Math.random()*W,Math.random()*H,1,`hsla(${hue},60%,50%,0.5)`,0.3,60);
  }
  drawParticles();

  // Title
  ctx.save();
  ctx.shadowColor=`hsl(${hue},100%,60%)`;
  ctx.shadowBlur=25;
  ctx.fillStyle=`hsl(${hue},100%,75%)`;
  ctx.font="bold 34px 'Segoe UI',system-ui,sans-serif";
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  ctx.fillText("NEON BOUNCE",W/2,H*0.22);
  ctx.shadowBlur=0;
  ctx.restore();

  ctx.fillStyle="#a0aac0";
  ctx.font="14px 'Segoe UI',system-ui,sans-serif";
  ctx.textAlign="center";
  ctx.fillText("Overdrive Lanes",W/2,H*0.22+28);

  // Bouncing preview ball
  const py=H*0.36+Math.sin(Date.now()*0.003)*12;
  ctx.save();
  ctx.beginPath();ctx.arc(W/2,py,BALL_R+2,0,Math.PI*2);
  ctx.fillStyle=`hsl(${hue},100%,70%)`;
  ctx.shadowColor=`hsl(${hue},100%,60%)`;
  ctx.shadowBlur=15;
  ctx.fill();
  ctx.shadowBlur=0;
  ctx.restore();

  // Instructions
  ctx.fillStyle="#7a8498";
  ctx.font="13px 'Segoe UI',system-ui,sans-serif";
  const iy=H*0.48;
  ctx.fillText("Tap or Space to bounce & switch lanes",W/2,iy);
  ctx.fillText("Land on glowing centers for combos",W/2,iy+22);
  ctx.fillText("Collect shards \u2666 to charge Overdrive",W/2,iy+44);

  // Best score
  if(best>0){
    ctx.fillStyle="#5a6478";
    ctx.font="13px 'Segoe UI',system-ui,sans-serif";
    ctx.fillText("Best: "+best,W/2,H*0.65);
  }

  // Challenge banner
  if(challengeTarget!==null){
    ctx.fillStyle="hsl(45,100%,65%)";
    ctx.font="bold 16px 'Segoe UI',system-ui,sans-serif";
    ctx.fillText("\u26a1 Challenge: Beat "+challengeTarget+" \u26a1",W/2,H*0.72);
  }

  // Tap prompt
  const tp=0.5+Math.sin(Date.now()*0.004)*0.35;
  ctx.fillStyle=`hsla(${hue},100%,80%,${tp})`;
  ctx.font="bold 18px 'Segoe UI',system-ui,sans-serif";
  ctx.fillText("TAP TO START",W/2,H*0.82);
}

function drawGameOver(){
  // Overlay
  ctx.fillStyle="rgba(8,12,24,0.78)";
  ctx.fillRect(-15,-15,W+30,H+30);

  drawParticles();

  ctx.textAlign="center";
  ctx.textBaseline="middle";

  // Game Over
  ctx.fillStyle="#ff4466";
  ctx.font="bold 30px 'Segoe UI',system-ui,sans-serif";
  ctx.fillText("GAME OVER",W/2,H*0.25);

  // Score
  ctx.fillStyle="#fff";
  ctx.font="bold 52px 'Segoe UI',system-ui,sans-serif";
  ctx.fillText(String(score),W/2,H*0.36);

  ctx.fillStyle="#6a7490";
  ctx.font="14px 'Segoe UI',system-ui,sans-serif";
  ctx.fillText("Best: "+best,W/2,H*0.36+36);

  // Challenge result
  if(challengeTarget!==null){
    const won=score>=challengeTarget;
    ctx.fillStyle=won?"#44ff88":"#ff6644";
    ctx.font="bold 15px 'Segoe UI',system-ui,sans-serif";
    ctx.fillText(won?"\u2714 Challenge beaten!":"\u2716 Need "+challengeTarget+" to win",W/2,H*0.36+62);
  }

  // Share button
  const bw=160, bh=40;
  const bx=W/2-bw/2, by=H*0.56;
  ctx.fillStyle=`hsl(${hue},65%,42%)`;
  roundRect(bx,by,bw,bh,10);
  ctx.fill();
  // Button glow
  ctx.save();
  ctx.shadowColor=`hsl(${hue},100%,50%)`;
  ctx.shadowBlur=10;
  ctx.fillStyle=`hsl(${hue},65%,42%)`;
  roundRect(bx,by,bw,bh,10);
  ctx.fill();
  ctx.shadowBlur=0;
  ctx.restore();

  ctx.fillStyle="#fff";
  ctx.font="bold 14px 'Segoe UI',system-ui,sans-serif";
  ctx.fillText("Challenge a Friend",W/2,by+bh/2);

  shareBtn.x=bx; shareBtn.y=by; shareBtn.w=bw; shareBtn.h=bh;

  // Restart prompt
  if(gameOverDelay<=0){
    const rp=0.4+Math.sin(Date.now()*0.004)*0.25;
    ctx.fillStyle=`hsla(0,0%,100%,${rp})`;
    ctx.font="14px 'Segoe UI',system-ui,sans-serif";
    ctx.fillText("Tap to restart",W/2,H*0.72);
  }

  ctx.textBaseline="alphabetic";
}

/* ======== Main loop ======== */
function loop(){
  update();
  draw();
  if(state!=="playing") hue=(hue+0.3)%360;
  requestAnimationFrame(loop);
}

initGame();
loop();

})();
</script>
</body>
</html>
