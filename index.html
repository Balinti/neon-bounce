<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Neon Bounce - Free HTML5 Game</title>
<meta name="description" content="Play Neon Bounce - Tap to bounce a glowing ball between neon platforms. Miss a platform and fall into the void. Platforms get narrower as score increases.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0a0014">
<link rel="canonical" href="https://balinti.github.io/neon-bounce/">
<meta property="og:type" content="website">
<meta property="og:title" content="Neon Bounce - Free HTML5 Game">
<meta property="og:description" content="Tap to flip between lanes and land on neon platforms. Build combos, charge bursts, and chase the high score!">
<meta property="og:url" content="https://balinti.github.io/neon-bounce/">
<meta property="og:image" content="https://balinti.github.io/neon-bounce/og.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Neon Bounce - Free HTML5 Game">
<meta name="twitter:description" content="Tap to flip between lanes and land on neon platforms. Build combos, charge bursts, and chase the high score!">
<meta name="twitter:image" content="https://balinti.github.io/neon-bounce/og.png">
<link rel="preconnect" href="https://pagead2.googlesyndication.com">
<link rel="preconnect" href="https://googleads.g.doubleclick.net">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0014;font-family:'Segoe UI',system-ui,sans-serif;color:#e0e0ff;touch-action:none;-webkit-tap-highlight-color:transparent;user-select:none}
#wrap{display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%;height:100%;min-height:100dvh}
canvas{display:block;image-rendering:crisp-edges}
#about{max-width:420px;width:100%;padding:14px 18px;color:#8888bb;font-size:12px;line-height:1.5;text-align:center;flex-shrink:0}
#about h2{font-size:14px;color:#aab;margin-bottom:4px}
#about a{color:#66f}
</style>
</head>
<body>
<div id="wrap">
<canvas id="c"></canvas>
<div id="about">
<h2>About Neon Bounce</h2>
<p>Neon Bounce is a free hyper-casual HTML5 game. Tap or press Space to flip gravity between the top and bottom neon lanes. Land on platforms to survive &mdash; hit the glowing core zone for combo multipliers and charge your Burst power. Miss a platform and shatter into the void. How far can you go?</p>
<p>Controls: Tap / Space / Enter to flip lanes. Works on desktop and mobile browsers.</p>
</div>
</div>
<script>
'use strict';
(function(){

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

/* ── Sizing ── */
let viewW, viewH, DPR;
function resize(){
  const wrap = canvas.parentElement;
  const maxW = Math.min(wrap.clientWidth, 420);
  const maxH = Math.min(wrap.clientHeight - 80, 750);
  viewW = Math.max(320, Math.min(maxW, 420));
  viewH = Math.max(480, Math.min(maxH, 750));
  DPR = Math.min(window.devicePixelRatio || 1, 2);
  canvas.width  = viewW * DPR;
  canvas.height = viewH * DPR;
  canvas.style.width  = viewW + 'px';
  canvas.style.height = viewH + 'px';
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
window.addEventListener('resize', resize);
resize();

/* ── Constants ── */
const PLAT_H     = 14;
const G0         = 2200;
const BOUNCE_V0  = 980;
const BALL_R     = 9;
const BURST_MAX  = 3;
const BURST_DUR  = 0.28;

/* ── State ── */
let state = 'start';
let score, bestScore, multiplier, coreStreak;
let burstCharge, burstReady, burstActive, burstTimer, skipNextGap;
let ball, platforms, particles, floatTexts;
let elapsed, spawnTimer, difficulty;
let shakeTimer, shakeMag;
let hue;
let challengeTarget = 0;

/* challenge param */
try {
  const p = new URLSearchParams(window.location.search);
  const ch = p.get('challenge');
  if (ch) challengeTarget = parseInt(ch, 10) || 0;
} catch(e){}

/* localStorage */
function loadBest(){ try{ return parseFloat(localStorage.getItem('neonbounce_best')) || 0; }catch(e){ return 0; } }
function saveBest(v){ try{ localStorage.setItem('neonbounce_best', String(v)); }catch(e){} }
bestScore = loadBest();

/* ── Audio (minimal WebAudio) ── */
let audioCtx = null;
function initAudio(){
  if (audioCtx) return;
  try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e){}
}
function beep(freq, dur, vol){
  if (!audioCtx) return;
  try {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine'; o.frequency.value = freq;
    g.gain.value = vol || 0.06;
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + dur);
  } catch(e){}
}

/* ── Helpers ── */
function lerp(a,b,t){ return a+(b-a)*t; }
function clamp(v,lo,hi){ return v<lo?lo:v>hi?hi:v; }
function rng(a,b){ return a+Math.random()*(b-a); }

/* ── Lane anchors ── */
function yTop(){ return viewH * 0.22; }
function yBot(){ return viewH * 0.78; }
function laneY(lane){ return lane === 0 ? yTop() : yBot(); }

/* ── Platform factory ── */
function makePlat(x, lane, wSafe, wCore){
  const anchor = laneY(lane);
  return {
    x: x, y: anchor - PLAT_H/2, w: wSafe, h: PLAT_H,
    coreW: wCore, lane: lane, scored: false,
    driftPh: rng(0, Math.PI*2),
    baseY: anchor - PLAT_H/2
  };
}

/* ── Init ── */
function initGame(){
  score = 0; multiplier = 1; coreStreak = 0;
  burstCharge = 0; burstReady = false; burstActive = false;
  burstTimer = 0; skipNextGap = false;
  elapsed = 0; spawnTimer = 0;
  shakeTimer = 0; shakeMag = 0;
  hue = rng(0, 360); difficulty = 0;

  ball = {
    x: viewW * 0.18,
    y: yBot() - PLAT_H/2 - BALL_R,
    vy: 0, lane: 1, trail: [], landed: true
  };

  platforms  = [];
  particles  = [];
  floatTexts = [];

  const wS = 120, wC = wS * 0.32;
  platforms.push(makePlat(ball.x - 30, 1, wS, wC));
  let px = ball.x - 30 + wS + 80;
  for (let i = 0; i < 6; i++){
    const ln = Math.random() < 0.5 ? 0 : 1;
    platforms.push(makePlat(px, ln, wS, wC));
    px += wS + rng(60, 100);
  }
}

/* ── Input ── */
function doFlip(){
  if (state === 'start'){
    initAudio(); state = 'playing'; initGame(); return;
  }
  if (state === 'gameover'){
    initAudio(); state = 'playing'; initGame(); return;
  }
  if (state === 'playing'){
    initAudio();
    ball.lane = ball.lane === 0 ? 1 : 0;
    ball.vy = (ball.lane === 1 ? 1 : -1) * 120;
    ball.landed = false;
    beep(440, 0.06, 0.04);
  }
}

let flipBlocked = false;
canvas.addEventListener('pointerdown', function(e){
  e.preventDefault();
  if (state === 'gameover' && handleGameOverClick(e)) return;
  doFlip();
});
document.addEventListener('keydown', function(e){
  if (e.code === 'Space' || e.code === 'Enter'){
    e.preventDefault(); doFlip();
  }
});

/* ── Particles ── */
function spawnSparks(x, y, n, color, speed, life){
  for (let i = 0; i < n; i++){
    const a = rng(0, Math.PI*2), s = rng(speed*0.3, speed);
    particles.push({
      x:x, y:y, vx:Math.cos(a)*s, vy:Math.sin(a)*s,
      life: rng(life*0.5, life), maxLife: life,
      color: color, size: rng(1.5, 4), ring: false
    });
  }
}
function spawnRing(x, y, color){
  particles.push({ x:x, y:y, vx:0, vy:0, life:0.35, maxLife:0.35, color:color, size:0, ring:true, ringR:5 });
}
function addFloat(x, y, text, color){
  floatTexts.push({ x:x, y:y, text:text, color:color, life:1.0, maxLife:1.0 });
}

/* ── Shake ── */
function shake(dur, mag){ shakeTimer = dur; shakeMag = mag; }

/* ── Die ── */
function die(){
  state = 'gameover';
  if (score > bestScore){ bestScore = score; saveBest(Math.floor(bestScore)); }
  shake(0.25, 12);
  spawnSparks(ball.x, ball.y, 80, 'hsl(0,100%,60%)', 350, 0.8);
  for (let i = 0; i < 12; i++){
    const a = rng(0, Math.PI*2), s = rng(100, 250);
    particles.push({
      x: ball.x+Math.cos(a)*5, y: ball.y+Math.sin(a)*5,
      vx: Math.cos(a)*s, vy: Math.sin(a)*s - 100,
      life: rng(0.5, 1.2), maxLife: 1.2,
      color: `hsl(${rng(0,60)|0},100%,60%)`, size: rng(4, 8), ring: false
    });
  }
  beep(120, 0.3, 0.1);
}

/* ── Update ── */
function update(dt){
  if (state !== 'playing') return;

  elapsed += dt;
  hue = (hue + 30*dt) % 360;

  /* difficulty curve */
  difficulty = 1 - Math.exp(-elapsed/22);
  const vScroll = 210 + 260 * difficulty;
  const bounceV = BOUNCE_V0 + 40 * difficulty;

  /* gravity */
  const gDir = ball.lane === 1 ? 1 : -1;
  if (!ball.landed) ball.vy += gDir * G0 * dt;
  ball.y += ball.vy * dt;

  /* burst timer */
  if (burstActive){ burstTimer -= dt; if (burstTimer <= 0) burstActive = false; }

  /* scroll */
  const scrollDx = vScroll * dt;
  score += (vScroll / 100) * dt;

  for (let i = platforms.length - 1; i >= 0; i--){
    const p = platforms[i];
    p.x -= scrollDx;

    /* moving drift after 10s */
    if (elapsed > 10){
      const amp = Math.min(26, 26 * (elapsed - 10) / 30);
      const freq = 1.2 + 0.8 * difficulty;
      p.y = p.baseY + Math.sin(elapsed * freq + p.driftPh) * amp;
    }

    if (p.x + p.w < -20){ platforms.splice(i, 1); }
  }

  /* missed platform death */
  for (let i = 0; i < platforms.length; i++){
    const p = platforms[i];
    if (!p.scored && p.x + p.w < ball.x - 10){
      if (burstActive || skipNextGap){ p.scored = true; skipNextGap = false; continue; }
      die(); return;
    }
  }

  /* collision */
  for (let i = 0; i < platforms.length; i++){
    const p = platforms[i];
    if (p.scored) continue;

    /* circle vs AABB */
    const nx = clamp(ball.x, p.x, p.x + p.w);
    const ny = clamp(ball.y, p.y, p.y + p.h);
    const dx = ball.x - nx, dy = ball.y - ny;
    if (dx*dx + dy*dy > BALL_R*BALL_R) continue;

    /* directional gate */
    if (p.lane === 1){
      if (ball.vy <= 0) continue;
      ball.y = p.y - BALL_R;
      ball.vy = -bounceV;
    } else {
      if (ball.vy >= 0) continue;
      ball.y = p.y + p.h + BALL_R;
      ball.vy = bounceV;
    }

    ball.landed = true;
    p.scored = true;

    /* core check */
    const coreX = p.x + (p.w - p.coreW)/2;
    const onCore = ball.x >= coreX && ball.x <= coreX + p.coreW;
    const edgeDist = Math.min(Math.abs(ball.x - p.x), Math.abs(ball.x - (p.x + p.w)));
    const isClutch = edgeDist < 12 && !onCore;

    if (onCore){
      coreStreak++;
      multiplier = 1 + 0.25 * Math.min(coreStreak, 12);
      if (multiplier > 4) multiplier = 4;
      score += 12 * multiplier;
      burstCharge = Math.min(burstCharge + 1, BURST_MAX);
      if (burstCharge >= BURST_MAX) burstReady = true;

      if (burstReady && burstCharge >= BURST_MAX){
        burstActive = true; burstTimer = BURST_DUR;
        score += 60 * multiplier;
        burstCharge = 0; burstReady = false; skipNextGap = true;
        shake(0.14, 7);
        spawnSparks(ball.x, ball.y, 30, `hsl(${hue|0},100%,70%)`, 300, 0.5);
        spawnRing(ball.x, ball.y, `hsl(${hue|0},100%,80%)`);
        addFloat(ball.x, ball.y - 20, 'BURST!', `hsl(${hue|0},100%,80%)`);
        beep(880, 0.15, 0.1);
      } else {
        shake(0.10, 4);
        const ch = (hue+60)|0;
        spawnSparks(ball.x, ball.y, 15, `hsl(${ch},100%,70%)`, 180, 0.35);
        spawnRing(ball.x, ball.y, `hsl(${ch},100%,70%)`);
        addFloat(ball.x, ball.y - 20, `CORE x${multiplier.toFixed(1)}`, `hsl(${ch},100%,80%)`);
        beep(660, 0.08, 0.06);
      }
    } else {
      score += 5 * multiplier;
      coreStreak = 0; multiplier = 1;
      shake(0.08, 2);
      spawnSparks(ball.x, ball.y, 8, `hsl(${((hue+120)|0)},80%,60%)`, 120, 0.25);
      beep(330, 0.05, 0.03);

      if (isClutch){
        score += 5;
        addFloat(ball.x, ball.y - 20, 'CLUTCH +5', '#ff0');
        shake(0.08, 3);
        beep(550, 0.08, 0.05);
      }
    }
    break;
  }

  /* death bounds */
  if (ball.y > viewH + 60 || ball.y < -60){ die(); return; }

  /* spawn */
  spawnTimer -= dt;
  if (spawnTimer <= 0){
    spawnTimer = Math.max(0.3, 0.95 - 0.38*difficulty + rng(-0.05, 0.05));
    const wSafe = lerp(120, 78, clamp(difficulty/1.6, 0, 1));
    const wCore = Math.max(18, wSafe * 0.32);
    const pSame = 0.08 + 0.22 * difficulty;
    const last = platforms[platforms.length - 1];
    let ln;
    if (last) ln = Math.random() < pSame ? last.lane : (last.lane === 0 ? 1 : 0);
    else ln = 1;
    platforms.push(makePlat(viewW + 20, ln, wSafe, wCore));
  }

  /* trail */
  ball.trail.unshift({x: ball.x, y: ball.y});
  if (ball.trail.length > 8) ball.trail.pop();

  updateParticles(dt);
}

function updateParticles(dt){
  for (let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    p.life -= dt;
    if (p.life <= 0){ particles.splice(i,1); continue; }
    if (p.ring){ p.ringR += 200*dt; }
    else { p.x += p.vx*dt; p.y += p.vy*dt; p.vy += 400*dt; }
  }
  for (let i = floatTexts.length - 1; i >= 0; i--){
    const f = floatTexts[i];
    f.life -= dt; f.y -= 50*dt;
    if (f.life <= 0) floatTexts.splice(i, 1);
  }
  if (shakeTimer > 0) shakeTimer -= dt;
}

/* ── Render ── */
function render(){
  ctx.save();

  /* shake */
  let sx = 0, sy = 0;
  if (shakeTimer > 0){
    sx = rng(-shakeMag, shakeMag);
    sy = rng(-shakeMag, shakeMag);
    ctx.translate(sx, sy);
  }

  /* bg */
  const bg = ctx.createLinearGradient(0, 0, 0, viewH);
  bg.addColorStop(0, '#0a0018');
  bg.addColorStop(0.5, '#0d0024');
  bg.addColorStop(1, '#08001a');
  ctx.fillStyle = bg;
  ctx.fillRect(-20, -20, viewW+40, viewH+40);

  /* scanlines */
  ctx.fillStyle = 'rgba(0,0,0,0.07)';
  for (let y = 0; y < viewH; y += 4) ctx.fillRect(0, y, viewW, 2);

  /* lane guides */
  ctx.strokeStyle = 'rgba(100,80,200,0.12)';
  ctx.lineWidth = 1;
  ctx.setLineDash([8,8]);
  ctx.beginPath();
  ctx.moveTo(0, yTop()); ctx.lineTo(viewW, yTop());
  ctx.moveTo(0, yBot()); ctx.lineTo(viewW, yBot());
  ctx.stroke();
  ctx.setLineDash([]);

  if (state === 'playing' || state === 'gameover'){
    /* platforms */
    for (const p of platforms){
      const ph = p.lane === 0 ? (hue+180)%360 : hue;
      ctx.fillStyle = `hsl(${ph|0},70%,32%)`;
      ctx.fillRect(p.x, p.y, p.w, p.h);
      ctx.strokeStyle = `hsl(${ph|0},80%,52%)`;
      ctx.lineWidth = 1.5;
      ctx.strokeRect(p.x, p.y, p.w, p.h);

      /* core */
      const cx = p.x + (p.w - p.coreW)/2;
      const cHue = (ph+60)%360;
      ctx.fillStyle = `hsl(${cHue},100%,58%)`;
      ctx.shadowBlur = 6;
      ctx.shadowColor = `hsl(${cHue},100%,68%)`;
      ctx.fillRect(cx, p.y+2, p.coreW, p.h-4);
      ctx.shadowBlur = 0;
    }

    /* ball trail */
    if (ball){
      for (let i = 0; i < ball.trail.length; i++){
        const t = ball.trail[i];
        const a = (1 - i/ball.trail.length) * 0.28;
        ctx.beginPath();
        ctx.arc(t.x, t.y, BALL_R*(1 - i*0.07), 0, Math.PI*2);
        ctx.fillStyle = `hsla(${hue|0},100%,70%,${a})`;
        ctx.fill();
      }

      /* ball */
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI*2);
      ctx.fillStyle = `hsl(${hue|0},100%,75%)`;
      ctx.shadowBlur = 14;
      ctx.shadowColor = `hsl(${hue|0},100%,65%)`;
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.strokeStyle = `hsl(${hue|0},100%,90%)`;
      ctx.lineWidth = 1.5;
      ctx.stroke();

      /* burst effects on ball */
      if (burstActive){
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, BALL_R+8, 0, Math.PI*2);
        ctx.strokeStyle = `hsla(${hue|0},100%,80%,0.55)`;
        ctx.lineWidth = 3; ctx.stroke();
      }
      if (burstReady && !burstActive){
        const pulse = 0.5 + 0.5*Math.sin((elapsed||0)*8);
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, BALL_R+5+pulse*3, 0, Math.PI*2);
        ctx.strokeStyle = `hsla(50,100%,70%,${(0.3+pulse*0.3).toFixed(2)})`;
        ctx.lineWidth = 2; ctx.stroke();
      }
    }

    /* particles */
    for (const p of particles){
      const a = clamp(p.life / p.maxLife, 0, 1);
      if (p.ring){
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.ringR, 0, Math.PI*2);
        ctx.strokeStyle = p.color.replace('hsl(','hsla(').replace(')',`,${a.toFixed(2)})`);
        ctx.lineWidth = 2*a; ctx.stroke();
      } else {
        ctx.globalAlpha = a;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x-p.size/2, p.y-p.size/2, p.size, p.size);
        ctx.globalAlpha = 1;
      }
    }

    /* float texts */
    ctx.textAlign = 'center';
    for (const f of floatTexts){
      const a = clamp(f.life / f.maxLife, 0, 1);
      ctx.globalAlpha = a;
      ctx.font = 'bold 14px "Segoe UI",system-ui,sans-serif';
      ctx.fillStyle = f.color;
      ctx.fillText(f.text, f.x, f.y);
    }
    ctx.globalAlpha = 1;

    /* HUD */
    ctx.textAlign = 'left';
    ctx.font = 'bold 22px "Segoe UI",system-ui,sans-serif';
    ctx.fillStyle = '#fff';
    ctx.fillText(Math.floor(score), 16, 34);

    ctx.font = '12px "Segoe UI",system-ui,sans-serif';
    ctx.fillStyle = '#999';
    ctx.fillText('BEST: ' + Math.floor(bestScore), 16, 52);

    if (multiplier > 1){
      ctx.textAlign = 'right';
      ctx.font = 'bold 16px "Segoe UI",system-ui,sans-serif';
      ctx.fillStyle = `hsl(${((hue+60)|0)},100%,75%)`;
      ctx.fillText('x' + multiplier.toFixed(1), viewW-16, 34);
    }

    /* burst pips */
    ctx.textAlign = 'right';
    const mX = viewW - 16, mY = 50;
    for (let i = 0; i < BURST_MAX; i++){
      const px = mX - (BURST_MAX-1-i)*14;
      ctx.beginPath(); ctx.arc(px, mY, 4, 0, Math.PI*2);
      if (i < burstCharge){
        ctx.fillStyle = burstReady ? '#ff0' : `hsl(${hue|0},100%,65%)`;
        ctx.fill();
      } else {
        ctx.strokeStyle = '#555'; ctx.lineWidth = 1; ctx.stroke();
      }
    }
    if (burstReady){
      ctx.font = 'bold 10px "Segoe UI",system-ui,sans-serif';
      ctx.fillStyle = '#ff0';
      ctx.fillText('BURST!', mX, mY+14);
    }

    /* challenge HUD */
    if (challengeTarget > 0 && state === 'playing'){
      ctx.textAlign = 'left';
      ctx.font = '11px "Segoe UI",system-ui,sans-serif';
      ctx.fillStyle = '#f80';
      ctx.fillText('Target: ' + challengeTarget, 16, 68);
    }
  }

  /* overlays */
  if (state === 'start') drawStart();
  if (state === 'gameover') drawGameOver();

  ctx.restore();
}

function drawStart(){
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0, 0, viewW, viewH);
  ctx.textAlign = 'center';

  ctx.font = 'bold 38px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle = `hsl(${(hue||200)|0},100%,75%)`;
  ctx.shadowBlur = 22;
  ctx.shadowColor = `hsl(${(hue||200)|0},100%,55%)`;
  ctx.fillText('Neon Bounce', viewW/2, viewH*0.34);
  ctx.shadowBlur = 0;

  ctx.font = '18px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle = '#ddd';
  ctx.fillText('Tap to Start', viewW/2, viewH*0.47);

  ctx.font = '13px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle = '#888';
  ctx.fillText('Tap / Space: Flip Lanes', viewW/2, viewH*0.54);

  if (challengeTarget > 0){
    ctx.font = 'bold 16px "Segoe UI",system-ui,sans-serif';
    ctx.fillStyle = '#f80';
    ctx.fillText('Challenge Target: ' + challengeTarget, viewW/2, viewH*0.63);
  }
  if (bestScore > 0){
    ctx.font = '14px "Segoe UI",system-ui,sans-serif';
    ctx.fillStyle = '#aaa';
    ctx.fillText('Best: ' + Math.floor(bestScore), viewW/2, viewH*0.70);
  }
}

/* ── Game Over button areas ── */
const goBtns = { share: null, challenge: null };

function drawGameOver(){
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(0, 0, viewW, viewH);
  ctx.textAlign = 'center';

  ctx.font = 'bold 30px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle = '#f44';
  ctx.fillText('Game Over', viewW/2, viewH*0.26);

  ctx.font = 'bold 42px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle = '#fff';
  ctx.fillText(Math.floor(score), viewW/2, viewH*0.37);

  ctx.font = '15px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle = '#aaa';
  ctx.fillText('Best: ' + Math.floor(bestScore), viewW/2, viewH*0.43);

  if (challengeTarget > 0){
    const beat = Math.floor(score) >= challengeTarget;
    ctx.font = 'bold 16px "Segoe UI",system-ui,sans-serif';
    ctx.fillStyle = beat ? '#0f0' : '#f80';
    ctx.fillText(beat ? 'Challenge Beat!' : 'Target: ' + challengeTarget, viewW/2, viewH*0.49);
  }

  ctx.font = '18px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle = '#ddd';
  ctx.fillText('Tap to Retry', viewW/2, viewH*0.57);

  /* buttons */
  const bW = 100, bH = 34, bY = viewH*0.63;
  const sX = viewW/2 - bW - 8, cX = viewW/2 + 8;

  drawBtn(sX, bY, bW, bH, 'Share', 'rgba(100,100,255,0.25)', '#88f', '#ccf');
  drawBtn(cX, bY, bW, bH, 'Challenge', 'rgba(255,150,0,0.18)', '#f80', '#fc8');

  goBtns.share = {x:sX,y:bY,w:bW,h:bH};
  goBtns.challenge = {x:cX,y:bY,w:bW,h:bH};
}

function drawBtn(x, y, w, h, text, bg, stroke, fg){
  ctx.fillStyle = bg;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1.5;
  rRect(x, y, w, h, 6);
  ctx.fill(); ctx.stroke();
  ctx.font = '14px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle = fg;
  ctx.textAlign = 'center';
  ctx.fillText(text, x+w/2, y+22);
}

function rRect(x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
  ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r);
  ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y);
  ctx.closePath();
}

function handleGameOverClick(e){
  const rect = canvas.getBoundingClientRect();
  const sx = viewW / rect.width, sy = viewH / rect.height;
  const mx = (e.clientX - rect.left)*sx, my = (e.clientY - rect.top)*sy;
  for (const [key, b] of Object.entries(goBtns)){
    if (b && mx>=b.x && mx<=b.x+b.w && my>=b.y && my<=b.y+b.h){
      if (key === 'share') doShare();
      else doChallenge();
      return true;
    }
  }
  return false;
}

function doShare(){
  const t = `I scored ${Math.floor(score)} in Neon Bounce! Can you beat me?`;
  const u = 'https://balinti.github.io/neon-bounce/';
  if (navigator.share) navigator.share({title:'Neon Bounce',text:t,url:u}).catch(()=>{});
  else copyTxt(t+' '+u);
}
function doChallenge(){
  const s = Math.floor(score);
  const u = `https://balinti.github.io/neon-bounce/?challenge=${s}`;
  const t = `I scored ${s} in Neon Bounce! Beat my score: ${u}`;
  if (navigator.share) navigator.share({title:'Neon Bounce Challenge',text:t,url:u}).catch(()=>{});
  else copyTxt(t);
}
function copyTxt(text){
  if (navigator.clipboard && navigator.clipboard.writeText){
    navigator.clipboard.writeText(text).then(()=> addFloat(viewW/2,viewH*0.75,'Copied!','#0f0')).catch(()=>{});
  } else {
    const ta=document.createElement('textarea'); ta.value=text;
    document.body.appendChild(ta); ta.select(); document.execCommand('copy');
    document.body.removeChild(ta);
    addFloat(viewW/2,viewH*0.75,'Copied!','#0f0');
  }
}

/* ── Loop ── */
let lastT = 0;
function loop(ts){
  requestAnimationFrame(loop);
  const dt = Math.min((ts - lastT)/1000, 0.05);
  lastT = ts;
  update(dt);
  render();
  if (state === 'gameover') updateParticles(dt);
}

initGame();
requestAnimationFrame(loop);

})();
</script>
</body>
</html>
