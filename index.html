<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Neon Bounce - Free HTML5 Game</title>
<meta name="description" content="Play Neon Bounce - Tap to bounce a glowing ball between neon platforms. Miss a platform and fall into the void. Platforms get narrower as score increases.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0a0a1a">
<link rel="canonical" href="https://balinti.github.io/neon-bounce/">

<meta property="og:type" content="website">
<meta property="og:title" content="Neon Bounce - Free HTML5 Game">
<meta property="og:description" content="Tap to flip gravity and bounce a glowing ball between neon platforms in a vertical neon tunnel. How long can you survive?">
<meta property="og:url" content="https://balinti.github.io/neon-bounce/">
<meta property="og:image" content="https://balinti.github.io/neon-bounce/og-image.jpg">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Neon Bounce - Free HTML5 Game">
<meta name="twitter:description" content="Tap to flip gravity and bounce a glowing ball between neon platforms in a vertical neon tunnel. How long can you survive?">
<meta name="twitter:image" content="https://balinti.github.io/neon-bounce/og-image.jpg">

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>

<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{
  width:100%;height:100%;
  overflow:hidden;
  background:#05050f;
  font-family:'Segoe UI',system-ui,-apple-system,sans-serif;
  touch-action:none;
  user-select:none;
  -webkit-user-select:none;
}
#wrap{
  display:flex;flex-direction:column;
  align-items:center;justify-content:center;
  height:100vh;height:100dvh;
}
#gameContainer{
  position:relative;
  background:#0a0a1a;
  border-radius:8px;
  overflow:hidden;
  box-shadow:0 0 40px rgba(80,200,255,0.06);
}
canvas{display:block}
#scoreUI{
  position:absolute;top:14px;left:0;right:0;
  text-align:center;
  color:#fff;font-size:28px;font-weight:700;
  text-shadow:0 0 12px rgba(100,220,255,0.5);
  pointer-events:none;opacity:0;transition:opacity .2s;z-index:2;
}
#scoreUI.vis{opacity:1}
#comboUI{
  position:absolute;top:48px;left:0;right:0;
  text-align:center;
  color:#ffcc00;font-size:15px;font-weight:600;
  text-shadow:0 0 8px rgba(255,200,0,0.4);
  pointer-events:none;opacity:0;transition:opacity .15s;z-index:2;
}
#comboUI.vis{opacity:1}
.ov{
  position:absolute;inset:0;
  display:flex;flex-direction:column;
  align-items:center;justify-content:center;
  z-index:10;pointer-events:none;
  opacity:0;transition:opacity .3s;
}
.ov.vis{opacity:1;pointer-events:auto}
.ov h1{
  font-size:38px;color:#fff;
  text-shadow:0 0 24px rgba(100,220,255,0.6);
  margin-bottom:6px;letter-spacing:3px;
}
.ov .sub{font-size:14px;color:rgba(255,255,255,0.5);margin-bottom:24px}
.ov .prompt{font-size:17px;color:rgba(255,255,255,0.75);animation:pulse 1.6s ease-in-out infinite}
.ov .stats{
  font-size:15px;color:rgba(255,255,255,0.65);
  line-height:1.9;text-align:center;margin-bottom:18px;
}
.ov .stats b{color:#fff;font-weight:700}
@keyframes pulse{0%,100%{opacity:.55;transform:scale(1)}50%{opacity:1;transform:scale(1.04)}}
#about{
  max-width:420px;margin:10px auto 0;padding:0 14px 20px;
  color:rgba(255,255,255,0.3);font-size:11px;line-height:1.55;text-align:center;
}
#about a{color:rgba(100,200,255,0.45);text-decoration:none}
</style>
</head>
<body>
<div id="wrap">
  <div id="gameContainer">
    <canvas id="c"></canvas>
    <div id="scoreUI">0</div>
    <div id="comboUI"></div>
    <div class="ov vis" id="startOv">
      <h1>NEON BOUNCE</h1>
      <div class="sub">Gravity Flip Combo</div>
      <div class="prompt">Tap or Press Space to Start</div>
    </div>
    <div class="ov" id="goOv">
      <h1>GAME OVER</h1>
      <div class="stats" id="goStats"></div>
      <div class="prompt">Tap to Retry</div>
    </div>
  </div>
</div>
<div id="about">
  <strong>How to Play Neon Bounce</strong><br>
  Tap the screen or press Space/Enter to flip gravity. Your ball bounces between floor and
  ceiling pads in a neon tunnel. Land on the bright center "Perfect Zone" to build combos and
  earn bonus points. If you miss a pad, you get a brief "Danger Fall" window &mdash; flip quickly
  to catch the next one! Platforms get narrower, hazard lasers appear, and fork choices emerge
  as your score rises. Chase the highest combo!<br>
  <br>&copy; 2025 Neon Bounce &middot;
  <a href="https://balinti.github.io/neon-bounce/">Play Online</a>
</div>

<script>
'use strict';
(()=>{

/* ═══ DOM ═══ */
const canvas   = document.getElementById('c');
const ctx      = canvas.getContext('2d');
const box      = document.getElementById('gameContainer');
const scoreEl  = document.getElementById('scoreUI');
const comboEl  = document.getElementById('comboUI');
const startOv  = document.getElementById('startOv');
const goOv     = document.getElementById('goOv');
const goStats  = document.getElementById('goStats');

/* ═══ CONSTANTS ═══ */
const G_MAG       = 2200;
const BALL_R      = 10;
const PAD_H       = 12;
const FLOOR_OFF   = 44;
const INPUT_DB    = 90;
const LS_KEY      = 'neonBounce_best';
const MAX_PARTS   = 600;
const TWO_PI      = Math.PI * 2;

/* ═══ SIZING ═══ */
let W, H, dpr;

function resize(){
  dpr = window.devicePixelRatio || 1;
  W = Math.min(window.innerWidth, 420);
  H = Math.min(window.innerHeight, 750);
  canvas.style.width  = W + 'px';
  canvas.style.height = H + 'px';
  canvas.width  = Math.round(W * dpr);
  canvas.height = Math.round(H * dpr);
  box.style.width  = W + 'px';
  box.style.height = H + 'px';
}
window.addEventListener('resize', resize);
resize();

/* ═══ STATE ═══ */
let state = 'start';
let score, bestScore, combo, maxCombo, perfects;
let ballX, ballY, ballVY, gSign;
let trail, pads, hazards;
let danger, dangerTimer, dangerMax;
let hitstopTimer, timeScale;
let lastInputT, gameTime, baseHue;
let shakeX, shakeY, shakeT;
let idleT = 0;

/* particle pool */
const PP = new Array(MAX_PARTS);
for(let i=0;i<MAX_PARTS;i++) PP[i]={alive:false};
let ppi = 0;

/* popup pool */
const POP = [];

bestScore = parseInt(localStorage.getItem(LS_KEY)) || 0;

/* ═══ HELPERS ═══ */
function clamp(v,lo,hi){ return v<lo?lo:v>hi?hi:v; }
function lerp(a,b,t){ return a+(b-a)*t; }
function rand(a,b){ return a+Math.random()*(b-a); }
function hsl(h,s,l,a){
  h=h|0; s=s|0; l=l|0;
  return a!==undefined ? `hsla(${h},${s}%,${l}%,${a})` : `hsl(${h},${s}%,${l}%)`;
}

/* ═══ PAD HELPERS ═══ */
function padW(risky){
  return risky ? clamp(200 - 1.6*score, 110, 200)
               : clamp(260 - 1.2*score, 160, 260);
}
function perfRatio(){ return clamp(0.55 - 0.0025*score, 0.30, 0.55); }

function spawnPad(side, fx){
  const risky = score >= 15 && Math.random() < 0.25;
  const w  = padW(risky);
  const pr = perfRatio();
  const pw = w * pr;
  const x  = fx !== undefined ? fx
    : clamp(rand(w/2+12, W-w/2-12), w/2+12, W-w/2-12);
  const dv = (score >= 10 && Math.random() < 0.35)
    ? rand(30,80)*(Math.random()<0.5?1:-1) : 0;
  return {x, w, side, perfectW: pw, driftV: dv, risky};
}

function nextSide(cur){
  if(score >= 10 && Math.random() < 0.18) return cur;
  return cur === 'floor' ? 'ceil' : 'floor';
}

/* ═══ HAZARD ═══ */
function trySpawnHazard(){
  if(score < 50 || Math.random() > 0.30) return;
  const y = rand(H*0.25, H*0.75);
  const w = rand(60, 140);
  const x = rand(w/2+10, W-w/2-10);
  hazards.push({x, y, w, timer:0, hit:false, life:rand(3,6)});
}

/* ═══ PARTICLES ═══ */
function emit(x,y,count,hu,speed,life,sz){
  for(let i=0;i<count;i++){
    const a = Math.random()*TWO_PI;
    const v = rand(speed*0.25, speed);
    const p = PP[ppi]; ppi=(ppi+1)%MAX_PARTS;
    p.alive=true; p.ring=false;
    p.x=x; p.y=y;
    p.vx=Math.cos(a)*v; p.vy=Math.sin(a)*v;
    p.life=p.max=rand(life*0.5,life);
    p.hue=hu+rand(-15,15);
    p.size=sz!==undefined?rand(sz*0.5,sz):rand(2,4.5);
  }
}
function emitRing(x,y,hu,maxR){
  const p = PP[ppi]; ppi=(ppi+1)%MAX_PARTS;
  p.alive=true; p.ring=true;
  p.x=x; p.y=y; p.vx=0; p.vy=0;
  p.radius=0; p.maxR=maxR||60;
  p.life=p.max=0.35;
  p.hue=hu; p.size=0;
}

/* ═══ POPUPS ═══ */
function popup(text,x,y,color,sz){
  POP.push({text,x,y,vy:-80,life:0.7,max:0.7,color,size:sz||18});
}

/* ═══ SHAKE ═══ */
function shake(mag,dur){
  shakeX=rand(-mag,mag); shakeY=rand(-mag,mag); shakeT=dur;
}

/* ═══ INIT ═══ */
function initGame(){
  score=0; combo=1; maxCombo=1; perfects=0;
  ballX=W/2; ballY=H/2; ballVY=0; gSign=1;
  trail=[]; pads=[]; hazards=[]; POP.length=0;
  for(let i=0;i<MAX_PARTS;i++) PP[i].alive=false;
  ppi=0;
  shakeX=shakeY=shakeT=0;
  danger=false; dangerTimer=0;
  hitstopTimer=0; timeScale=1;
  lastInputT=0; gameTime=0; baseHue=190;
  pads.push(spawnPad('floor', W/2));
  pads.push(spawnPad('ceil'));
}

/* ═══ INPUT ═══ */
function act(){
  const now = performance.now();
  if(now - lastInputT < INPUT_DB) return;
  lastInputT = now;
  if(state==='start'){
    state='playing'; initGame();
    startOv.classList.remove('vis');
    scoreEl.classList.add('vis');
    ballVY = 400*gSign;
    return;
  }
  if(state==='gameover'){
    state='playing'; initGame();
    goOv.classList.remove('vis');
    scoreEl.classList.add('vis');
    ballVY = 400*gSign;
    return;
  }
  if(state==='playing') flipGrav();
}

function flipGrav(){
  gSign *= -1;
  ballVY = gSign * Math.max(Math.abs(ballVY)*0.3, 200);
}

canvas.addEventListener('pointerdown', e=>{ e.preventDefault(); act(); });
document.addEventListener('keydown', e=>{
  if(e.code==='Space'||e.code==='Enter'){ e.preventDefault(); act(); }
});

/* ═══ BOUNCE SPEED ═══ */
function bounceSpd(){ return 1180 + Math.min(520, score*8); }

/* ═══ GAME OVER ═══ */
function gameOver(){
  state = 'gameover';
  if(score > bestScore){ bestScore=score; localStorage.setItem(LS_KEY,bestScore); }
  shake(14, 0.4);
  emit(ballX,ballY,40,baseHue,300,0.8,4);
  scoreEl.classList.remove('vis');
  comboEl.classList.remove('vis');
  goStats.innerHTML =
    `Score: <b>${score}</b><br>Best: <b>${bestScore}</b><br>Max Combo: <b>x${maxCombo}</b>`;
  setTimeout(()=>goOv.classList.add('vis'), 350);
}

/* ═══ UPDATE ═══ */
function update(dt){
  if(hitstopTimer > 0){ hitstopTimer -= dt; return; }

  const sdt = dt * timeScale;
  gameTime += sdt;
  baseHue = (190 + score*3 + gameTime*8) % 360;

  /* physics */
  ballVY += G_MAG * gSign * sdt;
  ballY  += ballVY * sdt;
  ballX   = clamp(ballX, BALL_R+4, W-BALL_R-4);

  /* trail */
  trail.push({x:ballX, y:ballY});
  if(trail.length > 10) trail.shift();

  /* pad drift */
  for(const p of pads){
    if(!p.driftV) continue;
    p.x += p.driftV * sdt;
    if(p.x - p.w/2 < 5){ p.x=p.w/2+5; p.driftV*=-1; }
    if(p.x + p.w/2 > W-5){ p.x=W-p.w/2-5; p.driftV*=-1; }
  }

  /* hazard update */
  for(let i=hazards.length-1;i>=0;i--){
    const hz=hazards[i];
    hz.timer += sdt;
    if(hz.timer > hz.life){ hazards.splice(i,1); continue; }
    if(!hz.hit && Math.abs(ballY-hz.y)<BALL_R+3
       && Math.abs(ballX-hz.x)<hz.w/2+BALL_R){
      hz.hit=true;
      combo=1; comboEl.classList.remove('vis');
      ballX += (ballX>hz.x?1:-1)*40;
      shake(5,0.15);
      emit(ballX,hz.y,12,0,150,0.4,3);
      popup('COMBO BREAK',ballX,hz.y,'#ff4466',14);
    }
  }

  /* pad collision */
  const floorY = H - FLOOR_OFF;
  const ceilY  = FLOOR_OFF;

  for(let i=0;i<pads.length;i++){
    const p=pads[i];
    const py = p.side==='floor' ? floorY : ceilY;
    const isFloor = p.side==='floor';
    const landing = isFloor
      ? (ballY+BALL_R >= py-PAD_H/2 && ballVY>0)
      : (ballY-BALL_R <= py+PAD_H/2 && ballVY<0);

    if(!landing) continue;
    if(Math.abs(ballX - p.x) > p.w/2 + BALL_R*0.5) continue;

    /* ── HIT ── */
    const dist = Math.abs(ballX - p.x);
    const isPerfect = dist < p.perfectW/2;

    score++;
    if(isPerfect){
      perfects++;
      combo = Math.min(combo+1, 10);
      if(combo>maxCombo) maxCombo=combo;
      score += 1 + 2*combo;
      emit(ballX,py,20,baseHue,250,0.6,3.5);
      emitRing(ballX,py,baseHue,60);
      popup('PERFECT',ballX,py-30*(isFloor?1:-1),'#ffee44',22);
      if(combo>2) popup(`x${combo}`,ballX,py-58*(isFloor?1:-1),'#66ffaa',16);
      shake(4,0.1);
      hitstopTimer=0.05;
    } else {
      combo=1; comboEl.classList.remove('vis');
      emit(ballX,py,10,baseHue+30,150,0.4,2.5);
      shake(2,0.06);
    }

    if(danger){
      danger=false; timeScale=1;
      popup('SAVED!',ballX,ballY-20,'#44ffcc',20);
      score+=1; hitstopTimer=0.03;
    }

    /* UI */
    scoreEl.textContent = score;
    if(combo>1){
      comboEl.textContent = `x${combo} COMBO`;
      comboEl.classList.add('vis');
    }

    /* bounce */
    ballY = isFloor ? py-PAD_H/2-BALL_R : py+PAD_H/2+BALL_R;
    const ns = nextSide(p.side);
    gSign = ns==='floor' ? 1 : -1;
    ballVY = gSign * bounceSpd();

    /* new pads */
    pads=[];
    pads.push(spawnPad(ns));
    if(score>=15 && Math.random()<0.3){
      pads.push(spawnPad(ns==='floor'?'ceil':'floor'));
    }
    trySpawnHazard();
    break;
  }

  /* danger / miss detection */
  const outBot = ballY - BALL_R > H + 10;
  const outTop = ballY + BALL_R < -10;
  if((outBot||outTop) && !danger){
    danger=true; dangerTimer=0;
    dangerMax = Math.max(0.32, 0.55-0.003*score);
    timeScale=0.85;
  }

  if(danger){
    dangerTimer += dt;
    if(dangerTimer > 0.4) timeScale=1;
    if(dangerTimer > dangerMax){ gameOver(); return; }
    ballY = clamp(ballY,-60,H+60);
  }

  /* particles */
  for(let i=0;i<MAX_PARTS;i++){
    const p=PP[i]; if(!p.alive) continue;
    p.life -= sdt;
    if(p.life<=0){ p.alive=false; continue; }
    if(p.ring){
      p.radius += (p.maxR/p.max)*sdt;
    } else {
      p.x+=p.vx*sdt; p.y+=p.vy*sdt;
      p.vy+=400*sdt; p.size*=0.97;
    }
  }

  /* popups */
  for(let i=POP.length-1;i>=0;i--){
    const p=POP[i];
    p.life -= sdt; if(p.life<=0){ POP.splice(i,1); continue; }
    p.y += p.vy*sdt;
  }

  /* shake decay */
  if(shakeT>0){
    shakeT-=dt; shakeX*=0.88; shakeY*=0.88;
  } else { shakeX=shakeY=0; }
}

/* ═══ DRAW ═══ */
function draw(){
  ctx.setTransform(dpr,0,0,dpr,0,0);

  /* background */
  const bg = ctx.createLinearGradient(0,0,0,H);
  if(danger && state==='playing'){
    const f = clamp(dangerTimer/dangerMax,0,1);
    bg.addColorStop(0, hsl(280,40,lerp(5,10,f)));
    bg.addColorStop(1, hsl(350,50,lerp(4,12,f)));
  } else {
    bg.addColorStop(0,'#0a0a1a');
    bg.addColorStop(1,'#0d0820');
  }
  ctx.fillStyle=bg;
  ctx.fillRect(0,0,W,H);

  /* tunnel lines */
  const th = state==='playing' ? baseHue : (190+idleT*15)%360;
  ctx.strokeStyle = hsl(th,70,30,0.15);
  ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(2,0); ctx.lineTo(2,H); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(W-2,0); ctx.lineTo(W-2,H); ctx.stroke();

  /* faint grid lines */
  ctx.strokeStyle = hsl(th,40,20,0.04);
  ctx.lineWidth=1;
  for(let y=0;y<H;y+=40){
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }

  /* shake translate */
  if(shakeT>0) ctx.translate(shakeX, shakeY);

  if(state==='start'){ drawIdle(); ctx.setTransform(dpr,0,0,dpr,0,0); return; }

  /* hazards */
  for(const hz of hazards){
    if(hz.hit) continue;
    const a = clamp(1-hz.timer/hz.life,0,1);
    ctx.strokeStyle=hsl(0,90,55,a*0.3); ctx.lineWidth=8;
    ctx.beginPath(); ctx.moveTo(hz.x-hz.w/2,hz.y); ctx.lineTo(hz.x+hz.w/2,hz.y); ctx.stroke();
    ctx.strokeStyle=hsl(0,90,70,a); ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(hz.x-hz.w/2,hz.y); ctx.lineTo(hz.x+hz.w/2,hz.y); ctx.stroke();
  }

  /* pads */
  const floorY=H-FLOOR_OFF, ceilY=FLOOR_OFF;
  for(const p of pads) drawPad(p, p.side==='floor'?floorY:ceilY);

  /* ball trail */
  for(let i=0;i<trail.length;i++){
    const t=trail[i];
    const a=(i+1)/trail.length*0.35;
    const r=BALL_R*(i+1)/trail.length*0.7;
    ctx.fillStyle=hsl(baseHue,80,65,a);
    ctx.beginPath(); ctx.arc(t.x,t.y,r,0,TWO_PI); ctx.fill();
  }

  /* ball glow layers */
  ctx.fillStyle=hsl(baseHue,85,60,0.18);
  ctx.beginPath(); ctx.arc(ballX,ballY,BALL_R*2.3,0,TWO_PI); ctx.fill();
  ctx.fillStyle=hsl(baseHue,80,55,0.45);
  ctx.beginPath(); ctx.arc(ballX,ballY,BALL_R*1.4,0,TWO_PI); ctx.fill();
  ctx.fillStyle=hsl(baseHue,90,75);
  ctx.beginPath(); ctx.arc(ballX,ballY,BALL_R,0,TWO_PI); ctx.fill();
  ctx.fillStyle='rgba(255,255,255,0.55)';
  ctx.beginPath(); ctx.arc(ballX-3,ballY-3,BALL_R*0.38,0,TWO_PI); ctx.fill();

  /* gravity arrow indicator */
  ctx.save();
  ctx.globalAlpha=0.25;
  ctx.strokeStyle=hsl(baseHue,70,70);
  ctx.lineWidth=2;
  const arrowY = ballY + gSign*18;
  ctx.beginPath();
  ctx.moveTo(ballX, ballY+gSign*10);
  ctx.lineTo(ballX, arrowY);
  ctx.moveTo(ballX-5, arrowY-gSign*5);
  ctx.lineTo(ballX, arrowY);
  ctx.lineTo(ballX+5, arrowY-gSign*5);
  ctx.stroke();
  ctx.restore();

  /* particles */
  for(let i=0;i<MAX_PARTS;i++){
    const p=PP[i]; if(!p.alive) continue;
    const a=clamp(p.life/p.max,0,1);
    if(p.ring){
      ctx.strokeStyle=hsl(p.hue,80,65,a*0.6);
      ctx.lineWidth=2.5*a;
      ctx.beginPath(); ctx.arc(p.x,p.y,p.radius,0,TWO_PI); ctx.stroke();
    } else {
      ctx.fillStyle=hsl(p.hue,85,65,a);
      ctx.beginPath(); ctx.arc(p.x,p.y,Math.max(p.size*a,0.5),0,TWO_PI); ctx.fill();
    }
  }

  /* popups */
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  for(const p of POP){
    const a=clamp(p.life/p.max,0,1);
    ctx.globalAlpha=a;
    ctx.font=`bold ${p.size}px 'Segoe UI',system-ui,sans-serif`;
    ctx.fillStyle=p.color;
    ctx.fillText(p.text,p.x,p.y);
  }
  ctx.globalAlpha=1;
  ctx.textBaseline='alphabetic';

  /* danger overlay */
  if(danger){
    const f=clamp(dangerTimer/dangerMax,0,1);
    ctx.fillStyle=`rgba(255,30,60,${f*0.12})`;
    ctx.fillRect(0,0,W,H);
  }

  ctx.setTransform(dpr,0,0,dpr,0,0);
}

/* ═══ PAD DRAW ═══ */
function drawPad(p, py){
  const hu = p.risky ? (baseHue+120)%360 : baseHue;

  /* glow */
  ctx.fillStyle=hsl(hu,70,50,0.10);
  rr(ctx,p.x-(p.w+18)/2,py-PAD_H/2-4,p.w+18,PAD_H+8,8);
  ctx.fill();

  /* body */
  ctx.fillStyle=hsl(hu,65,40,0.70);
  rr(ctx,p.x-p.w/2,py-PAD_H/2,p.w,PAD_H,6);
  ctx.fill();

  /* core line */
  ctx.strokeStyle=hsl(hu,80,65,0.85);
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(p.x-p.w/2+4, py);
  ctx.lineTo(p.x+p.w/2-4, py);
  ctx.stroke();

  /* perfect zone fill */
  const phu=(hu+60)%360;
  ctx.fillStyle=hsl(phu,90,65,0.30);
  rr(ctx,p.x-p.perfectW/2,py-PAD_H/2+1,p.perfectW,PAD_H-2,4);
  ctx.fill();

  /* perfect zone bright line */
  ctx.strokeStyle=hsl(phu,90,70,0.55);
  ctx.lineWidth=1.5;
  ctx.beginPath();
  ctx.moveTo(p.x-p.perfectW/2+3, py);
  ctx.lineTo(p.x+p.perfectW/2-3, py);
  ctx.stroke();

  /* risky label */
  if(p.risky){
    ctx.fillStyle=hsl(hu,80,60,0.4);
    ctx.font="bold 9px 'Segoe UI',system-ui,sans-serif";
    ctx.textAlign='center';
    ctx.fillText('RISKY',p.x,py+(p.side==='floor'?-PAD_H/2-5:PAD_H/2+11));
  }
}

/* ═══ IDLE ═══ */
function drawIdle(){
  const t=idleT;
  const ix=W/2+Math.sin(t*1.2)*40;
  const iy=H/2+Math.sin(t*2)*60;
  const ih=(190+t*15)%360;

  /* fake trail */
  for(let i=0;i<6;i++){
    const off=(i+1)*0.08;
    const a=(i+1)/6*0.2;
    ctx.fillStyle=hsl(ih,80,60,a);
    const bx=W/2+Math.sin((t-off)*1.2)*40;
    const by=H/2+Math.sin((t-off)*2)*60;
    ctx.beginPath(); ctx.arc(bx,by,BALL_R*(i+1)/6*0.7,0,TWO_PI); ctx.fill();
  }
  ctx.fillStyle=hsl(ih,85,55,0.2);
  ctx.beginPath(); ctx.arc(ix,iy,BALL_R*2,0,TWO_PI); ctx.fill();
  ctx.fillStyle=hsl(ih,90,70);
  ctx.beginPath(); ctx.arc(ix,iy,BALL_R,0,TWO_PI); ctx.fill();
  ctx.fillStyle='rgba(255,255,255,0.5)';
  ctx.beginPath(); ctx.arc(ix-3,iy-3,3.5,0,TWO_PI); ctx.fill();

  /* decorative pads */
  const dhu=ih;
  ctx.fillStyle=hsl(dhu,65,40,0.35);
  rr(ctx,W/2-60,H-FLOOR_OFF-PAD_H/2,120,PAD_H,6);
  ctx.fill();
  ctx.fillStyle=hsl(dhu,65,40,0.35);
  rr(ctx,W/2-55,FLOOR_OFF-PAD_H/2,110,PAD_H,6);
  ctx.fill();
}

/* ═══ ROUND RECT ═══ */
function rr(c,x,y,w,h,r){
  c.beginPath();
  c.moveTo(x+r,y);
  c.lineTo(x+w-r,y);
  c.quadraticCurveTo(x+w,y,x+w,y+r);
  c.lineTo(x+w,y+h-r);
  c.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  c.lineTo(x+r,y+h);
  c.quadraticCurveTo(x,y+h,x,y+h-r);
  c.lineTo(x,y+r);
  c.quadraticCurveTo(x,y,x+r,y);
  c.closePath();
}

/* ═══ MAIN LOOP ═══ */
let prevT=0;
function loop(ts){
  requestAnimationFrame(loop);
  const raw = prevT ? (ts-prevT)/1000 : 0.016;
  prevT = ts;
  const dt = Math.min(raw, 0.033);

  if(state==='playing') update(dt);
  else if(state==='start') idleT+=dt;

  draw();
}
requestAnimationFrame(loop);

})();
</script>
</body>
</html>
