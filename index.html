<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Neon Bounce - Free HTML5 Game</title>
<meta name="description" content="Play Neon Bounce - Tap to bounce a glowing ball between neon platforms. Miss a platform and fall into the void. Platforms get narrower as score increases.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0a0014">
<link rel="canonical" href="https://balinti.github.io/neon-bounce/">
<meta property="og:type" content="website">
<meta property="og:title" content="Neon Bounce - Free HTML5 Game">
<meta property="og:description" content="Play Neon Bounce - Tap to bounce a glowing ball between neon platforms. Miss a platform and fall into the void. Platforms get narrower as score increases.">
<meta property="og:url" content="https://balinti.github.io/neon-bounce/">
<meta property="og:image" content="https://balinti.github.io/neon-bounce/og.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Neon Bounce - Free HTML5 Game">
<meta name="twitter:description" content="Play Neon Bounce - Tap to bounce a glowing ball between neon platforms. Miss a platform and fall into the void. Platforms get narrower as score increases.">
<meta name="twitter:image" content="https://balinti.github.io/neon-bounce/og.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0014;font-family:'Segoe UI',system-ui,sans-serif;color:#e0e0ff;touch-action:none;-webkit-tap-highlight-color:transparent;user-select:none}
#wrap{display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%;height:100%;min-height:100dvh}
#game-container{position:relative;width:100%;max-width:420px;max-height:750px;aspect-ratio:420/750;flex-shrink:1}
#hud{position:absolute;top:0;left:0;right:0;height:36px;display:flex;align-items:center;justify-content:space-between;padding:0 14px;font-size:13px;font-weight:600;z-index:10;pointer-events:none;letter-spacing:0.5px}
#hud-score{color:#fff}
#hud-combo{color:#ffcc00;opacity:0}
#hud-best{color:#88aaff;font-size:11px}
canvas{display:block;width:100%;height:100%;image-rendering:crisp-edges}
#overlay{position:absolute;top:0;left:0;right:0;bottom:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:20;pointer-events:none}
#overlay.active{pointer-events:auto}
#overlay-title{font-size:32px;font-weight:800;letter-spacing:2px;text-shadow:0 0 20px rgba(100,140,255,0.6);margin-bottom:8px;opacity:0;transform:translateY(-10px);transition:opacity 0.3s,transform 0.3s}
#overlay-sub{font-size:14px;color:#aab;margin-bottom:20px;opacity:0;transition:opacity 0.4s 0.15s}
#overlay-score{font-size:48px;font-weight:900;color:#fff;text-shadow:0 0 30px rgba(255,200,60,0.5);opacity:0;transition:opacity 0.3s 0.05s}
#overlay-best-label{font-size:13px;color:#88aaff;margin-top:4px;opacity:0;transition:opacity 0.3s 0.15s}
#overlay-tap{font-size:15px;color:#ccccee;margin-top:24px;opacity:0;animation:none;transition:opacity 0.3s 0.25s}
#overlay.active #overlay-title,#overlay.active #overlay-sub,#overlay.active #overlay-score,#overlay.active #overlay-best-label,#overlay.active #overlay-tap{opacity:1}
#overlay.active #overlay-title{transform:translateY(0)}
#overlay.active #overlay-tap{animation:pulse 1.8s ease-in-out infinite 0.5s}
@keyframes pulse{0%,100%{opacity:0.6}50%{opacity:1}}
#about{max-width:420px;width:100%;padding:14px 18px;color:#8888bb;font-size:12px;line-height:1.5;text-align:center;flex-shrink:0}
#about h2{font-size:14px;color:#aab;margin-bottom:4px}
#about a{color:#66f}
</style>
</head>
<body>
<div id="wrap">
  <div id="game-container">
    <div id="hud">
      <span id="hud-score">0</span>
      <span id="hud-combo"></span>
      <span id="hud-best">BEST: 0</span>
    </div>
    <canvas id="c"></canvas>
    <div id="overlay" class="active">
      <div id="overlay-title">NEON BOUNCE</div>
      <div id="overlay-sub">Flip polarity. Ride the rails.</div>
      <div id="overlay-score"></div>
      <div id="overlay-best-label"></div>
      <div id="overlay-tap">Tap to Start</div>
    </div>
  </div>
  <div id="about">
    <h2>How to Play</h2>
    <p>Tap or press Space/Enter to flip between the ceiling and floor rails. Time your flips to avoid gaps and dodge laser beads. Build combos with perfect flips for bonus points. Scrape the edge of a gap for a dramatic grind save!</p>
    <p style="margin-top:6px">Play Neon Bounce - Tap to bounce a glowing ball between neon platforms. Miss a platform and fall into the void. Platforms get narrower as score increases. A free hyper-casual HTML5 neon arcade game playable in any browser.</p>
  </div>
</div>
<script>
'use strict';
(()=>{
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
const hudScore=document.getElementById('hud-score');
const hudCombo=document.getElementById('hud-combo');
const hudBest=document.getElementById('hud-best');
const overlay=document.getElementById('overlay');
const overlayTitle=document.getElementById('overlay-title');
const overlaySub=document.getElementById('overlay-sub');
const overlayScore=document.getElementById('overlay-score');
const overlayBestLabel=document.getElementById('overlay-best-label');
const overlayTap=document.getElementById('overlay-tap');
const container=document.getElementById('game-container');

let W,H,dpr;
let state='start'; // start | playing | gameover
let score,bestScore,combo,comboMax;
let scrollX,speed,lastTime;
let playerY,playerSide; // 0=floor,1=ceiling
let flipping,flipFrom,flipTo,flipT,flipDur;
let fallTimer,coyoteTime;
let slowMo,slowMoTimer,slowMoDur,slowMoScale;
let shakeTime,shakeMag;
let gates,beads,particles,trail;
let bgHue,distTravelled;
let grindSaved;

const PLAYER_X_FRAC=0.28;
const RAIL_THICK=16;
const BALL_R=9;
const FLIP_DUR=0.28;
const COYOTE=0.09;
const SCRAPE_DIST=14;
const SLOWMO_DUR=0.15;
const SLOWMO_SCALE=0.35;
const MAX_PARTICLES=200;
const TRAIL_LEN=12;

const FLOOR_HUE=38;
const CEIL_HUE=275;

function loadBest(){bestScore=parseInt(localStorage.getItem('nb_best'))||0}
function saveBest(){localStorage.setItem('nb_best',bestScore.toString())}

function resize(){
  const rect=container.getBoundingClientRect();
  dpr=window.devicePixelRatio||1;
  W=rect.width;
  H=rect.height;
  canvas.width=W*dpr;
  canvas.height=H*dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize',resize);

function difficulty(){return 1-Math.exp(-score/85)}
function getSpeed(d){return 240+220*d}
function spawnInterval(d){return Math.max(0.62,1.6-0.98*d)}
function gapLength(d){return 92+58*d}
function riskThick(d){return Math.max(8,14-6*d)}
function beadSpeed(d){return 60+120*d}

function smoothstep(t){return t*t*(3-2*t)}

function initGame(){
  score=0;combo=0;comboMax=0;
  scrollX=0;distTravelled=0;
  const d=difficulty();
  speed=getSpeed(d);
  playerSide=0;
  playerY=floorY();
  flipping=false;flipT=0;
  fallTimer=0;coyoteTime=0;
  slowMo=false;slowMoTimer=0;
  shakeTime=0;shakeMag=0;
  grindSaved=false;
  gates=[];beads=[];particles=[];trail=[];
  bgHue=220;
  spawnInitialGates();
}

function floorY(){return H-RAIL_THICK-BALL_R}
function ceilY(){return RAIL_THICK+BALL_R}
function tunnelTop(){return 0}
function tunnelBot(){return H}
function playerScreenX(){return W*PLAYER_X_FRAC}

function spawnInitialGates(){
  let x=W+100;
  for(let i=0;i<8;i++){
    spawnGate(x);
    x+=spawnInterval(difficulty())*getSpeed(difficulty())*1.2;
  }
}

let nextSpawnDist=0;
function spawnGate(atX){
  const d=difficulty();
  const gl=gapLength(d);
  const side=Math.random()<0.5?0:1; // 0=floor gap, 1=ceil gap
  const isRisk=Math.random()<0.3+0.3*d;
  const rt=isRisk?riskThick(d):RAIL_THICK;
  gates.push({
    x:atX!=null?atX:scrollX+W+50,
    width:gl,
    side:side,
    risk:isRisk,
    railThick:rt,
    scored:false
  });
  // Spawn beads on risk rails
  if(isRisk&&score>15){
    const bx=atX!=null?atX+gl/2:scrollX+W+50+gl/2;
    const bside=1-side; // bead on the opposite (risk) side
    beads.push({
      x:bx,
      side:bside,
      speed:beadSpeed(d)*(Math.random()<0.5?1:-1),
      r:5,
      alive:true,
      rangeStart:atX!=null?atX-10:scrollX+W+40,
      rangeEnd:(atX!=null?atX:scrollX+W+50)+gl+10
    });
  }
}

function doFlip(){
  if(flipping)return;
  if(state!=='playing')return;
  flipping=true;
  flipFrom=playerSide;
  flipTo=1-playerSide;
  flipT=0;
  flipDur=FLIP_DUR;
  playerSide=flipTo;
  fallTimer=0;
  coyoteTime=0;
  grindSaved=false;
  // Perfect flip bonus: if flipping while inside a gap on current side
  let perfect=false;
  const px=playerScreenX()+scrollX;
  for(const g of gates){
    if(g.side===flipFrom&&px>g.x&&px<g.x+g.width){
      perfect=true;break;
    }
  }
  if(perfect){
    combo++;
    if(combo>comboMax)comboMax=combo;
    score+=combo*2;
    spawnPerfectParticles();
  }
}

function spawnPerfectParticles(){
  const px=playerScreenX();
  const py=playerY;
  for(let i=0;i<12;i++){
    const a=Math.random()*Math.PI*2;
    const sp=80+Math.random()*120;
    particles.push({
      x:px,y:py,
      vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,
      life:0.6+Math.random()*0.3,maxLife:0.6+Math.random()*0.3,
      r:2+Math.random()*2,
      hue:45+Math.random()*30,
      gravity:0
    });
  }
}

function spawnGrindParticles(){
  const px=playerScreenX();
  const py=playerY;
  for(let i=0;i<20;i++){
    const a=Math.random()*Math.PI*2;
    const sp=50+Math.random()*150;
    particles.push({
      x:px,y:py,
      vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,
      life:0.4+Math.random()*0.4,maxLife:0.4+Math.random()*0.4,
      r:1.5+Math.random()*3,
      hue:30+Math.random()*20,
      gravity:200
    });
  }
}

function spawnDeathParticles(){
  const px=playerScreenX();
  const py=playerY;
  for(let i=0;i<35;i++){
    const a=Math.random()*Math.PI*2;
    const sp=60+Math.random()*200;
    particles.push({
      x:px,y:py,
      vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,
      life:0.7+Math.random()*0.5,maxLife:0.7+Math.random()*0.5,
      r:2+Math.random()*4,
      hue:0+Math.random()*30,
      gravity:150
    });
  }
}

function spawnTrail(){
  if(trail.length>=TRAIL_LEN)trail.shift();
  trail.push({x:playerScreenX(),y:playerY,a:1});
}

function gameOver(){
  state='gameover';
  shakeTime=0.35;shakeMag=12;
  spawnDeathParticles();
  if(score>bestScore){bestScore=score;saveBest();}
  setTimeout(()=>{
    overlayTitle.textContent='GAME OVER';
    overlaySub.textContent='';
    overlayScore.textContent=score;
    overlayBestLabel.textContent='BEST: '+bestScore;
    overlayTap.textContent='Tap to Retry';
    overlay.classList.add('active');
  },400);
}

function startGame(){
  overlay.classList.remove('active');
  initGame();
  state='playing';
}

function handleInput(){
  if(state==='start'||state==='gameover'){
    startGame();
  } else if(state==='playing'){
    doFlip();
  }
}

document.addEventListener('pointerdown',(e)=>{e.preventDefault();handleInput()});
document.addEventListener('keydown',(e)=>{
  if(e.code==='Space'||e.code==='Enter'){e.preventDefault();handleInput();}
});

function update(dt){
  if(state!=='playing')dt*=0.5; // slow particle updates when not playing

  let timeScale=1;
  if(slowMo){
    slowMoTimer-=dt;
    if(slowMoTimer<=0){slowMo=false;slowMoTimer=0;}
    else timeScale=SLOWMO_SCALE;
  }
  const adt=dt*timeScale;

  if(state==='playing'){
    const d=difficulty();
    speed=getSpeed(d);
    scrollX+=speed*adt;
    distTravelled+=speed*adt;
    score=Math.floor(distTravelled/50);

    // Update flip
    if(flipping){
      flipT+=adt/flipDur;
      if(flipT>=1){
        flipT=1;flipping=false;
        playerY=flipTo===0?floorY():ceilY();
      } else {
        const t=smoothstep(flipT);
        const fromY=flipFrom===0?floorY():ceilY();
        const toY=flipTo===0?floorY():ceilY();
        playerY=fromY+(toY-fromY)*t;
      }
    }

    // Gate spawning
    const lastGate=gates.length>0?gates[gates.length-1]:null;
    const spawnDist=spawnInterval(d)*speed;
    if(!lastGate||lastGate.x<scrollX+W+50){
      const nx=lastGate?lastGate.x+lastGate.width+spawnDist:scrollX+W+100;
      spawnGate(nx);
    }

    // Collision with gaps
    const px=playerScreenX()+scrollX;
    let inGap=false;
    let nearEdge=false;
    if(!flipping){
      for(const g of gates){
        if(g.side===playerSide&&px>g.x&&px<g.x+g.width){
          inGap=true;
          // Check edge scrape
          const distToStart=px-g.x;
          const distToEnd=g.x+g.width-px;
          if(distToStart<SCRAPE_DIST||distToEnd<SCRAPE_DIST){
            nearEdge=true;
          }
          break;
        }
      }
    }

    if(inGap&&!flipping){
      if(fallTimer===0&&coyoteTime===0){
        coyoteTime=COYOTE;
      }
      if(coyoteTime>0){
        coyoteTime-=adt;
        if(coyoteTime<=0){
          // Coyote expired
          if(nearEdge&&!grindSaved){
            // Grind save!
            grindSaved=true;
            slowMo=true;slowMoTimer=SLOWMO_DUR;
            shakeTime=0.2;shakeMag=8;
            combo=0;
            spawnGrindParticles();
          } else if(!grindSaved){
            fallTimer+=adt;
            if(fallTimer>0.05){
              gameOver();return;
            }
          }
        }
      } else if(!grindSaved){
        fallTimer+=adt;
        if(fallTimer>0.05){
          gameOver();return;
        }
      }
    } else {
      fallTimer=0;coyoteTime=0;grindSaved=false;
    }

    // Score gates
    for(const g of gates){
      if(!g.scored&&g.x+g.width<px){
        g.scored=true;
        // Distance scoring handled by distTravelled
      }
    }

    // Remove off-screen gates
    gates=gates.filter(g=>g.x+g.width>scrollX-50);

    // Update beads
    for(const b of beads){
      if(!b.alive)continue;
      b.x+=b.speed*adt;
      if(b.x<b.rangeStart||b.x>b.rangeEnd)b.speed*=-1;
      // Collision with player
      const bsx=b.x-scrollX;
      const bsy=b.side===0?floorY():ceilY();
      const dx=playerScreenX()-bsx;
      const dy=playerY-bsy;
      if(Math.sqrt(dx*dx+dy*dy)<BALL_R+b.r+2){
        b.alive=false;
        combo=0;
        // Pop particles
        for(let i=0;i<8;i++){
          const a=Math.random()*Math.PI*2;
          const sp=40+Math.random()*80;
          particles.push({
            x:bsx,y:bsy,
            vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,
            life:0.4,maxLife:0.4,
            r:2+Math.random()*2,
            hue:0,gravity:100
          });
        }
      }
    }
    beads=beads.filter(b=>b.alive&&b.x>scrollX-100);

    // HUD
    hudScore.textContent=score;
    if(combo>1){
      hudCombo.textContent='x'+combo;
      hudCombo.style.opacity='1';
    } else {
      hudCombo.style.opacity='0';
    }
    hudBest.textContent='BEST: '+bestScore;

    bgHue=220+score*0.3;
  }

  // Shake
  if(shakeTime>0)shakeTime-=dt;

  // Particles
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x+=p.vx*dt;
    p.y+=p.vy*dt;
    p.vy+=p.gravity*dt;
    p.life-=dt;
    if(p.life<=0){particles.splice(i,1);}
  }
  if(particles.length>MAX_PARTICLES)particles.splice(0,particles.length-MAX_PARTICLES);

  // Trail
  if(state==='playing'){
    spawnTrail();
  }
  for(const t of trail)t.a*=0.88;
  trail=trail.filter(t=>t.a>0.05);
}

function draw(){
  ctx.save();
  // Screen shake
  let sx=0,sy=0;
  if(shakeTime>0){
    const s=shakeTime/0.35;
    sx=(Math.random()-0.5)*shakeMag*s;
    sy=(Math.random()-0.5)*shakeMag*s;
    ctx.translate(sx,sy);
  }

  // Background gradient
  const h=bgHue%360;
  const grad=ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0,`hsl(${(h+40)%360},40%,5%)`);
  grad.addColorStop(0.5,`hsl(${h},50%,8%)`);
  grad.addColorStop(1,`hsl(${(h-20+360)%360},45%,5%)`);
  ctx.fillStyle=grad;
  ctx.fillRect(-20,-20,W+40,H+40);

  // Draw tunnel rails
  drawRails();

  // Draw gates (gaps in rails)
  drawGates();

  // Draw beads
  drawBeads();

  // Draw trail
  for(const t of trail){
    ctx.beginPath();
    ctx.arc(t.x,t.y,BALL_R*0.6*t.a,0,Math.PI*2);
    const ph=playerSide===0?FLOOR_HUE:CEIL_HUE;
    ctx.fillStyle=`hsla(${ph},80%,60%,${t.a*0.4})`;
    ctx.fill();
  }

  // Draw player
  if(state==='playing'||state==='start'){
    drawPlayer();
  }

  // Draw particles
  for(const p of particles){
    const a=p.life/p.maxLife;
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.r*a,0,Math.PI*2);
    ctx.fillStyle=`hsla(${p.hue},90%,60%,${a})`;
    ctx.fill();
  }

  ctx.restore();
}

function drawRails(){
  // Floor rail
  const floorGrad=ctx.createLinearGradient(0,H-RAIL_THICK,0,H);
  floorGrad.addColorStop(0,`hsla(${FLOOR_HUE},80%,50%,0.9)`);
  floorGrad.addColorStop(1,`hsla(${FLOOR_HUE},80%,30%,0.6)`);
  ctx.fillStyle=floorGrad;
  ctx.fillRect(0,H-RAIL_THICK,W,RAIL_THICK);

  // Floor rail glow
  ctx.shadowColor=`hsla(${FLOOR_HUE},90%,55%,0.5)`;
  ctx.shadowBlur=12;
  ctx.fillRect(0,H-RAIL_THICK,W,2);
  ctx.shadowBlur=0;

  // Ceiling rail
  const ceilGrad=ctx.createLinearGradient(0,0,0,RAIL_THICK);
  ceilGrad.addColorStop(0,`hsla(${CEIL_HUE},70%,30%,0.6)`);
  ceilGrad.addColorStop(1,`hsla(${CEIL_HUE},70%,50%,0.9)`);
  ctx.fillStyle=ceilGrad;
  ctx.fillRect(0,0,W,RAIL_THICK);

  ctx.shadowColor=`hsla(${CEIL_HUE},90%,55%,0.5)`;
  ctx.shadowBlur=12;
  ctx.fillRect(0,RAIL_THICK-2,W,2);
  ctx.shadowBlur=0;
}

function drawGates(){
  for(const g of gates){
    const gx=g.x-scrollX;
    if(gx>W+20||gx+g.width<-20)continue;
    // Draw gap (cut out rail section)
    const railY=g.side===0?H-RAIL_THICK:0;
    // Clear the gap area
    ctx.fillStyle=`hsla(0,0%,0%,0.85)`;
    ctx.fillRect(gx,railY,g.width,RAIL_THICK);

    // Gap edge glow
    const edgeHue=g.side===0?FLOOR_HUE:CEIL_HUE;
    ctx.strokeStyle=`hsla(${edgeHue},90%,65%,0.7)`;
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(gx,railY);ctx.lineTo(gx,railY+RAIL_THICK);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(gx+g.width,railY);ctx.lineTo(gx+g.width,railY+RAIL_THICK);
    ctx.stroke();

    // Risk indicator
    if(g.risk){
      const oppY=g.side===0?0:H-g.railThick;
      // Slightly thinner rail on opposite side for risk
      ctx.fillStyle=`hsla(${g.side===0?CEIL_HUE:FLOOR_HUE},60%,40%,0.3)`;
      ctx.fillRect(gx,oppY,g.width,g.railThick);
      // Danger marks
      ctx.strokeStyle=`hsla(0,80%,55%,0.35)`;
      ctx.lineWidth=1;
      for(let lx=gx+8;lx<gx+g.width-8;lx+=12){
        ctx.beginPath();
        ctx.moveTo(lx,oppY+2);ctx.lineTo(lx+6,oppY+g.railThick-2);
        ctx.stroke();
      }
    }
  }
}

function drawBeads(){
  for(const b of beads){
    if(!b.alive)continue;
    const bx=b.x-scrollX;
    if(bx<-20||bx>W+20)continue;
    const by=b.side===0?H-RAIL_THICK/2:RAIL_THICK/2;
    ctx.beginPath();
    ctx.arc(bx,by,b.r,0,Math.PI*2);
    ctx.fillStyle=`hsla(0,90%,60%,0.9)`;
    ctx.fill();
    ctx.shadowColor=`hsla(0,100%,50%,0.8)`;
    ctx.shadowBlur=10;
    ctx.fill();
    ctx.shadowBlur=0;
  }
}

function drawPlayer(){
  const px=playerScreenX();
  const py=playerY;
  const hue=playerSide===0?FLOOR_HUE:CEIL_HUE;
  const flipHue=flipping?(flipFrom===0?FLOOR_HUE:CEIL_HUE):hue;

  // Outer glow
  ctx.beginPath();
  ctx.arc(px,py,BALL_R+6,0,Math.PI*2);
  ctx.fillStyle=`hsla(${hue},80%,55%,0.15)`;
  ctx.fill();

  // Ball
  ctx.beginPath();
  ctx.arc(px,py,BALL_R,0,Math.PI*2);
  const ballGrad=ctx.createRadialGradient(px-2,py-2,1,px,py,BALL_R);
  ballGrad.addColorStop(0,`hsla(${hue},90%,80%,1)`);
  ballGrad.addColorStop(1,`hsla(${hue},80%,50%,1)`);
  ctx.fillStyle=ballGrad;
  ctx.fill();

  // Glow
  ctx.shadowColor=`hsla(${hue},100%,60%,0.7)`;
  ctx.shadowBlur=18;
  ctx.beginPath();
  ctx.arc(px,py,BALL_R*0.7,0,Math.PI*2);
  ctx.fillStyle=`hsla(${hue},90%,70%,0.5)`;
  ctx.fill();
  ctx.shadowBlur=0;

  // Combo ring
  if(combo>1){
    ctx.beginPath();
    ctx.arc(px,py,BALL_R+3+combo*0.5,0,Math.PI*2);
    ctx.strokeStyle=`hsla(50,100%,65%,${0.3+combo*0.05})`;
    ctx.lineWidth=1.5;
    ctx.stroke();
  }
}

function drawStartScreen(){
  // Decorative background lines
  const t=performance.now()/1000;
  ctx.globalAlpha=0.15;
  for(let i=0;i<6;i++){
    const y=H*0.2+i*(H*0.1);
    const offset=Math.sin(t+i*0.8)*30;
    ctx.strokeStyle=`hsla(${220+i*25},70%,55%,0.5)`;
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(0,y+offset);
    ctx.bezierCurveTo(W*0.3,y-20+offset,W*0.7,y+20+offset,W,y+offset);
    ctx.stroke();
  }
  ctx.globalAlpha=1;
}

let lastTs=0;
function loop(ts){
  requestAnimationFrame(loop);
  if(!lastTs)lastTs=ts;
  let dt=(ts-lastTs)/1000;
  lastTs=ts;
  if(dt>0.033)dt=0.033;
  if(dt<=0)return;

  update(dt);

  ctx.clearRect(0,0,W,H);

  if(state==='start'){
    bgHue=220+Math.sin(performance.now()/3000)*15;
    drawStartScreen();
    drawRails();
    drawPlayer();
  }

  if(state==='playing'){
    draw();
  }

  if(state==='gameover'){
    draw();
  }

  // Draw particles on top always
  if(state!=='playing'){
    for(const p of particles){
      const a=p.life/p.maxLife;
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.r*a,0,Math.PI*2);
      ctx.fillStyle=`hsla(${p.hue},90%,60%,${a})`;
      ctx.fill();
    }
  }
}

function init(){
  loadBest();
  hudBest.textContent='BEST: '+bestScore;
  resize();
  playerY=floorY();
  playerSide=0;
  bgHue=220;
  scrollX=0;
  gates=[];beads=[];particles=[];trail=[];
  flipping=false;
  slowMo=false;shakeTime=0;
  overlayTitle.textContent='NEON BOUNCE';
  overlaySub.textContent='Flip polarity. Ride the rails.';
  overlayScore.textContent='';
  overlayBestLabel.textContent=bestScore>0?'BEST: '+bestScore:'';
  overlayTap.textContent='Tap to Start';
  overlay.classList.add('active');
  requestAnimationFrame(loop);
}

init();
})();
</script>
</body>
</html>
