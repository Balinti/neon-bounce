<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Neon Bounce - Free HTML5 Game</title>
<meta name="description" content="Play Neon Bounce - Tap to bounce a glowing ball between neon platforms. Miss a platform and fall into the void. Platforms get narrower as score increases.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0b0b14">
<meta name="robots" content="index, follow">
<meta property="og:type" content="website">
<meta property="og:title" content="Neon Bounce - Free HTML5 Game">
<meta property="og:description" content="Tap to flip gravity and bounce a glowing ball between neon platforms in a scrolling tunnel. How long can you survive?">
<meta property="og:url" content="https://balinti.github.io/neon-bounce/">
<meta property="og:image" content="https://balinti.github.io/neon-bounce/og.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Neon Bounce - Free HTML5 Game">
<meta name="twitter:description" content="Tap to flip gravity and bounce between neon platforms. How long can you survive?">
<meta name="twitter:image" content="https://balinti.github.io/neon-bounce/og.png">
<link rel="canonical" href="https://balinti.github.io/neon-bounce/">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#07070d;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;color:#fff}
#wrap{position:relative;width:100%;max-width:420px;height:100vh;max-height:750px;margin:0 auto;display:flex;flex-direction:column;align-items:center;justify-content:center}
canvas{display:block;width:100%;height:100%;touch-action:none;border-radius:8px}
#seo{position:fixed;bottom:0;left:0;right:0;background:#0b0b14;color:#556;font-size:11px;line-height:1.4;text-align:center;padding:6px 12px;z-index:10;max-height:36px;overflow:hidden;transition:max-height .3s;cursor:pointer}
#seo.open{max-height:200px;overflow-y:auto}
#seo h2{font-size:12px;color:#778;margin-bottom:2px}
#seo p{margin:2px 0}
</style>
</head>
<body>
<div id="wrap"><canvas id="c"></canvas></div>
<div id="seo" onclick="this.classList.toggle('open')">
<h2>Neon Bounce - Free HTML5 Hyper-Casual Game</h2>
<p>Tap or press Space to flip gravity polarity. Land on neon pads scrolling through a tunnel. Score points with combos and perfect landings. Difficulty increases over time. No downloads - play instantly in your browser!</p>
<p>Keywords: neon bounce, HTML5 game, hyper-casual, browser game, free online game, tap game, gravity flip, polarity</p>
</div>
<script>
'use strict';
(()=>{

/* =============================================
   NEON POLARITY BOUNCE
   Single-file HTML5 Canvas 2D game
   ============================================= */

const CANVAS = document.getElementById('c');
const CTX = CANVAS.getContext('2d');
const WRAP = document.getElementById('wrap');

// --- CONSTANTS ---
const LS_KEY = 'npb_highscore_v1';
const BALL_R = 9;
const GRAVITY = 2000;          // px/s^2
const FLIP_VEL = 560;          // velocity applied on flip
const PAD_SPEED_BASE = 155;    // px/s scroll at start
const PAD_SPEED_MAX = 370;     // px/s scroll at max difficulty
const PAD_GAP_BASE = 170;      // horizontal distance between pads
const PAD_GAP_MIN = 100;
const PAD_W_BASE = 95;
const PAD_W_MIN = 40;
const PAD_H = 9;
const COYOTE_TIME = 0.09;      // seconds of grace after leaving a pad
const VOID_KILL_FRAC = 0.52;   // fraction toward center before death
const COMBO_PERFECT_DIST = 14; // px from pad center
const COMBO_NEAR_DIST = 32;
const TRAIL_LEN = 14;
const MAX_PARTICLES = 220;
const SHAKE_DECAY = 9;
const SAFE_BOTTOM = 0.12;      // bottom 12% reserved
const TUNNEL_MARGIN = 0.14;    // lane offset from edges
const DIFFICULTY_TIME = 180;   // seconds to reach max difficulty

// --- GAME STATE ---
let W, H, DPR;
let state = 'start';
let ball, pads, particles, rings, trail;
let polarity;                  // 1=floor, -1=ceiling
let score, points, combo, maxCombo, bestPoints;
let elapsed, difficulty;
let shakeX, shakeY, shakeMag;
let hue, coyoteTimer;
let lastLandedPad;
let challengeTarget = 0;
let flashMsg = '', flashTimer = 0;
let lastTime = 0;

// Parse challenge from URL
try {
  const u = new URLSearchParams(location.search);
  if (u.has('challenge')) challengeTarget = parseInt(u.get('challenge')) || 0;
} catch(e) {}

// Load best score
bestPoints = parseInt(localStorage.getItem(LS_KEY)) || 0;

function saveBest() {
  if (points > bestPoints) {
    bestPoints = points;
    try { localStorage.setItem(LS_KEY, bestPoints); } catch(e) {}
  }
}

// --- RESIZE ---
function resize() {
  const rect = WRAP.getBoundingClientRect();
  DPR = Math.min(window.devicePixelRatio || 1, 2);
  W = rect.width;
  H = rect.height;
  CANVAS.width = W * DPR;
  CANVAS.height = H * DPR;
  CANVAS.style.width = W + 'px';
  CANVAS.style.height = H + 'px';
  CTX.setTransform(DPR, 0, 0, DPR, 0, 0);
}
window.addEventListener('resize', resize);
resize();

// --- HELPERS ---
function lerp(a, b, t) { return a + (b - a) * t; }
function clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; }
function rand(a, b) { return a + Math.random() * (b - a); }

// Lane Y positions
function floorY() { return H * (1 - TUNNEL_MARGIN - SAFE_BOTTOM * 0.5); }
function ceilY()  { return H * TUNNEL_MARGIN; }
function centerY(){ return (floorY() + ceilY()) * 0.5; }
function voidTop(){ return lerp(centerY(), ceilY(), 1 - VOID_KILL_FRAC); }
function voidBot(){ return lerp(centerY(), floorY(), VOID_KILL_FRAC); }

// Difficulty curve 0..1
function calcDiff(t) { return Math.min(1, t / DIFFICULTY_TIME); }
function spd()  { return lerp(PAD_SPEED_BASE, PAD_SPEED_MAX, difficulty); }
function padW() { return lerp(PAD_W_BASE, PAD_W_MIN, difficulty); }
function padG() { return lerp(PAD_GAP_BASE, PAD_GAP_MIN, difficulty); }

// Pad types
function pickType() {
  const r = Math.random();
  if (difficulty > 0.35 && r < 0.10) return 'narrow';
  if (difficulty > 0.15 && r < 0.20) return 'boost';
  if (difficulty > 0.45 && r < 0.28) return 'fragile';
  return 'normal';
}

function typeColor(type, h) {
  switch(type) {
    case 'narrow':  return `hsl(${(h+130)%360},90%,58%)`;
    case 'boost':   return `hsl(${(h+55)%360},100%,62%)`;
    case 'fragile': return `hsl(${(h+200)%360},65%,52%)`;
    default:        return `hsl(${h%360},100%,60%)`;
  }
}

// --- INIT ---
function initGame() {
  polarity = 1;
  score = 0;
  points = 0;
  combo = 1;
  maxCombo = 1;
  elapsed = 0;
  difficulty = 0;
  shakeX = 0; shakeY = 0; shakeMag = 0;
  hue = 210;
  coyoteTimer = 0;
  lastLandedPad = null;
  flashMsg = ''; flashTimer = 0;

  const fy = floorY();
  ball = {
    x: W * 0.22,
    y: fy - BALL_R - PAD_H * 0.5,
    vy: 0,
    onPad: true,
    alive: true
  };

  pads = [];
  particles = [];
  rings = [];
  trail = [];

  // Starting pad
  pads.push(makePad(ball.x, 1, 'normal', PAD_W_BASE));

  // Pre-fill pads ahead
  let lx = ball.x;
  for (let i = 0; i < 14; i++) {
    lx += padG() + rand(-12, 18);
    const lane = Math.random() < 0.5 ? 1 : -1;
    const t = i < 2 ? 'normal' : pickType();
    pads.push(makePad(lx, lane, t));
  }
}

function makePad(x, lane, type, forceW) {
  const w = forceW || (type === 'narrow' ? padW() * 0.55 : padW());
  return {
    x, y: lane === 1 ? floorY() : ceilY(),
    w, lane, type,
    hit: false, breaking: 0
  };
}

// --- SPAWN PADS ---
function spawnPads() {
  let last = pads[pads.length - 1];
  if (!last) return;
  const limit = W + padG() * 3;
  while (last.x < limit) {
    const gap = padG() + rand(-15, 22);
    const nx = last.x + gap;
    const lane = Math.random() < 0.5 ? 1 : -1;
    const p = makePad(nx, lane, pickType());
    pads.push(p);
    last = p;
  }
}

// --- PARTICLES & EFFECTS ---
function emit(x, y, count, baseH, spread, speed) {
  for (let i = 0; i < count && particles.length < MAX_PARTICLES; i++) {
    const a = rand(0, Math.PI * 2);
    const v = rand(speed * 0.3, speed);
    particles.push({
      x, y,
      vx: Math.cos(a) * v + rand(-spread, spread),
      vy: Math.sin(a) * v + rand(-spread, spread),
      life: 1,
      decay: rand(1.8, 3.5),
      r: rand(1.5, 4),
      hue: baseH + rand(-30, 30)
    });
  }
}

function ring(x, y, h) {
  rings.push({ x, y, r: 4, maxR: 55, life: 1, hue: h });
}

function shake(mag) { shakeMag = Math.max(shakeMag, mag); }

function flash(msg) { flashMsg = msg; flashTimer = 1.2; }

// --- INPUT ---
let pendingFlip = false;

function handleInput(e) {
  if (e) e.preventDefault();
  if (state === 'start')    { state = 'playing'; initGame(); return; }
  if (state === 'gameover') { state = 'playing'; initGame(); return; }
  if (state === 'playing')  { pendingFlip = true; }
}

function doFlip() {
  polarity *= -1;
  ball.onPad = false;
  ball.vy = -FLIP_VEL * polarity;
  coyoteTimer = 0;
  lastLandedPad = null;
  emit(ball.x, ball.y, 6, hue + 90, 18, 70);
}

// Pointer (works for touch + mouse)
CANVAS.addEventListener('pointerdown', e => {
  // Check share button first on gameover
  if (state === 'gameover' && shareBtn) {
    const rect = CANVAS.getBoundingClientRect();
    const sx = (e.clientX - rect.left) * (W / rect.width);
    const sy = (e.clientY - rect.top)  * (H / rect.height);
    if (sx >= shareBtn.x && sx <= shareBtn.x + shareBtn.w &&
        sy >= shareBtn.y && sy <= shareBtn.y + shareBtn.h) {
      e.preventDefault();
      doShare();
      return;
    }
  }
  handleInput(e);
});

document.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'Enter' || e.key === ' ') handleInput(e);
});

// --- SHARE ---
let shareBtn = null;

function doShare() {
  const text = `I scored ${points} points (${score} landings) in Neon Bounce! Can you beat me?\nhttps://balinti.github.io/neon-bounce/?challenge=${points}`;
  if (navigator.share) {
    navigator.share({ title:'Neon Bounce', text }).catch(()=>{});
  } else if (navigator.clipboard) {
    navigator.clipboard.writeText(text).then(() => flash('Copied!')).catch(()=>{});
  }
}

// --- UPDATE ---
function update(dt) {
  if (state !== 'playing') return;

  elapsed += dt;
  difficulty = calcDiff(elapsed);
  hue = (hue + dt * 22) % 360;

  // Process pending flip
  if (pendingFlip) { doFlip(); pendingFlip = false; }

  const speed = spd();

  // Move pads leftward
  for (let i = pads.length - 1; i >= 0; i--) {
    const p = pads[i];
    p.x -= speed * dt;
    if (p.type === 'fragile' && p.hit) {
      p.breaking += dt * 2.8;
      if (p.breaking >= 1) { pads.splice(i, 1); continue; }
    }
    if (p.x + p.w * 0.5 < -60) { pads.splice(i, 1); }
  }

  spawnPads();

  // Ball physics
  if (ball.onPad && lastLandedPad) {
    // Stay on pad surface
    const lp = lastLandedPad;
    if (lp.lane === 1) ball.y = lp.y - BALL_R - PAD_H * 0.5;
    else               ball.y = lp.y + BALL_R + PAD_H * 0.5;

    // Walked off the pad edge?
    const hw = lp.w * 0.5;
    if (ball.x < lp.x - hw - BALL_R * 0.5 || ball.x > lp.x + hw + BALL_R * 0.5) {
      ball.onPad = false;
      lastLandedPad = null;
      coyoteTimer = COYOTE_TIME;
    }
  } else {
    // Air: gravity
    ball.vy += GRAVITY * polarity * dt;
    ball.y += ball.vy * dt;
  }

  if (coyoteTimer > 0) coyoteTimer -= dt;

  // Collision with pads
  if (!ball.onPad) {
    for (const p of pads) {
      if (p.breaking > 0.6) continue;

      // Must be heading toward correct lane
      const toFloor = polarity === 1 && p.lane === 1 && ball.vy > 0;
      const toCeil  = polarity === -1 && p.lane === -1 && ball.vy < 0;
      if (!toFloor && !toCeil) continue;

      // Horizontal overlap (ball center vs pad extents + radius)
      const hw = p.w * 0.5;
      if (ball.x < p.x - hw - BALL_R || ball.x > p.x + hw + BALL_R) continue;

      // Vertical collision
      let landed = false;
      if (p.lane === 1) {
        const surface = p.y - PAD_H * 0.5;
        const ballBot = ball.y + BALL_R;
        const sweep = Math.abs(ball.vy) * dt + 15;
        if (ballBot >= surface && ballBot <= surface + sweep) {
          ball.y = surface - BALL_R;
          landed = true;
        }
      } else {
        const surface = p.y + PAD_H * 0.5;
        const ballTop = ball.y - BALL_R;
        const sweep = Math.abs(ball.vy) * dt + 15;
        if (ballTop <= surface && ballTop >= surface - sweep) {
          ball.y = surface + BALL_R;
          landed = true;
        }
      }

      if (landed) {
        ball.vy = 0;
        ball.onPad = true;
        lastLandedPad = p;
        p.hit = true;
        onLand(p);
        break;
      }
    }
  }

  // Death: ball drifts past void kill line
  if (!ball.onPad && coyoteTimer <= 0) {
    const cy = centerY();
    if ((polarity === 1  && ball.y > cy + 8) ||
        (polarity === -1 && ball.y < cy - 8)) {
      die();
    }
  }
  // Off screen safety
  if (ball.y < -80 || ball.y > H + 80) die();

  // Trail
  trail.unshift({ x: ball.x, y: ball.y });
  if (trail.length > TRAIL_LEN) trail.pop();

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.life -= p.decay * dt;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Update rings
  for (let i = rings.length - 1; i >= 0; i--) {
    const r = rings[i];
    r.r += (r.maxR - r.r) * dt * 5;
    r.life -= dt * 2.2;
    if (r.life <= 0) rings.splice(i, 1);
  }

  // Shake
  if (shakeMag > 0.15) {
    shakeMag *= Math.exp(-SHAKE_DECAY * dt);
    shakeX = (Math.random() - 0.5) * shakeMag * 2;
    shakeY = (Math.random() - 0.5) * shakeMag * 2;
  } else {
    shakeMag = 0; shakeX = 0; shakeY = 0;
  }

  // Flash timer
  if (flashTimer > 0) flashTimer -= dt;
}

function onLand(p) {
  score++;
  const dist = Math.abs(ball.x - p.x);
  let bonus = 1;
  let perfect = false, near = false;

  if (dist < COMBO_PERFECT_DIST) {
    combo = Math.min(combo + 1, 15);
    bonus = 3;
    perfect = true;
  } else if (dist < COMBO_NEAR_DIST) {
    combo = Math.min(combo + 0.5, 15);
    bonus = 2;
    near = true;
  } else {
    combo = Math.max(1, combo - 0.5);
  }

  if (combo > maxCombo) maxCombo = combo;
  const gained = Math.round(bonus * combo);
  points += gained;

  // Boost pad extra
  if (p.type === 'boost') {
    const extra = Math.round(5 * combo);
    points += extra;
    emit(ball.x, ball.y, 14, hue + 55, 35, 130);
    shake(2.5);
    flash(`BOOST +${gained + extra}`);
  }

  // Visual feedback
  emit(ball.x, ball.y, perfect ? 20 : 8, hue, 25, perfect ? 160 : 80);
  if (perfect) {
    ring(ball.x, ball.y, hue);
    shake(3);
    flash('PERFECT!');
  } else if (near) {
    shake(1.5);
    flash(`+${gained}`);
  }
}

function die() {
  if (state !== 'playing') return;
  ball.alive = false;
  state = 'gameover';
  saveBest();
  shake(14);
  emit(ball.x, ball.y, 45, hue, 60, 220);
  ring(ball.x, ball.y, hue);
  ring(ball.x, ball.y, hue + 80);
}

// --- DRAW ---
function draw() {
  CTX.save();
  CTX.clearRect(0, 0, W, H);

  // Background
  const bg = CTX.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, '#090912');
  bg.addColorStop(0.5, '#0e0e1e');
  bg.addColorStop(1, '#090912');
  CTX.fillStyle = bg;
  CTX.fillRect(0, 0, W, H);

  if (state === 'start') { drawStart(); CTX.restore(); return; }

  CTX.save();
  CTX.translate(shakeX, shakeY);

  drawTunnel();
  drawPads();
  drawRings();
  drawTrail();
  drawParticles();
  if (ball.alive) drawBall();
  drawHUD();
  if (flashTimer > 0) drawFlash();

  CTX.restore();

  if (state === 'gameover') drawGameOver();

  CTX.restore();
}

function drawTunnel() {
  const fy = floorY(), cy2 = ceilY(), ctr = centerY();

  // Lane glows
  CTX.fillStyle = `hsla(${(hue+180)%360},50%,25%,0.06)`;
  CTX.fillRect(0, fy - 25, W, 50);
  CTX.fillRect(0, cy2 - 25, W, 50);

  // Lane lines
  CTX.strokeStyle = `hsla(${(hue+180)%360},40%,35%,0.2)`;
  CTX.lineWidth = 1;
  CTX.beginPath();
  CTX.moveTo(0, fy); CTX.lineTo(W, fy);
  CTX.moveTo(0, cy2); CTX.lineTo(W, cy2);
  CTX.stroke();

  // Void center line
  const pulse = 0.12 + 0.08 * Math.sin((elapsed || 0) * 3);
  CTX.strokeStyle = `hsla(0,70%,45%,${pulse})`;
  CTX.lineWidth = 1;
  CTX.setLineDash([5, 8]);
  CTX.beginPath();
  CTX.moveTo(0, ctr); CTX.lineTo(W, ctr);
  CTX.stroke();
  CTX.setLineDash([]);

  // Scrolling grid lines for depth
  if (state === 'playing') {
    CTX.strokeStyle = 'rgba(255,255,255,0.02)';
    CTX.lineWidth = 1;
    const off = (elapsed * spd() * 0.3) % 40;
    for (let x = -off; x < W + 40; x += 40) {
      CTX.beginPath();
      CTX.moveTo(x, cy2); CTX.lineTo(x, fy);
      CTX.stroke();
    }
  }
}

function drawPads() {
  for (const p of pads) {
    const alpha = p.type === 'fragile' ? Math.max(0, 1 - p.breaking) : 1;
    const col = typeColor(p.type, hue);

    CTX.save();
    CTX.globalAlpha = alpha;

    // Glow
    CTX.shadowColor = col;
    CTX.shadowBlur = p.hit ? 20 : 10;
    CTX.fillStyle = col;

    const x = p.x - p.w * 0.5;
    const y = p.y - PAD_H * 0.5;
    const r = 4;

    CTX.beginPath();
    CTX.moveTo(x + r, y);
    CTX.lineTo(x + p.w - r, y);
    CTX.arcTo(x + p.w, y, x + p.w, y + r, r);
    CTX.lineTo(x + p.w, y + PAD_H - r);
    CTX.arcTo(x + p.w, y + PAD_H, x + p.w - r, y + PAD_H, r);
    CTX.lineTo(x + r, y + PAD_H);
    CTX.arcTo(x, y + PAD_H, x, y + PAD_H - r, r);
    CTX.lineTo(x, y + r);
    CTX.arcTo(x, y, x + r, y, r);
    CTX.closePath();
    CTX.fill();

    CTX.shadowBlur = 0;

    // Top highlight
    CTX.fillStyle = 'hsla(0,0%,100%,0.2)';
    CTX.fillRect(x + 4, y + 2, p.w - 8, 2);

    // Boost arrows
    if (p.type === 'boost') {
      CTX.fillStyle = 'hsla(0,0%,100%,0.45)';
      CTX.font = 'bold 9px sans-serif';
      CTX.textAlign = 'center';
      CTX.textBaseline = 'middle';
      CTX.fillText('\u00BB\u00BB', p.x, p.y);
    }

    // Fragile cracks
    if (p.type === 'fragile' && p.hit) {
      CTX.strokeStyle = `hsla(0,0%,100%,${0.4 * (1 - p.breaking)})`;
      CTX.lineWidth = 1;
      CTX.beginPath();
      CTX.moveTo(p.x - 6, y); CTX.lineTo(p.x, y + PAD_H);
      CTX.moveTo(p.x + 4, y); CTX.lineTo(p.x + 10, y + PAD_H);
      CTX.stroke();
    }

    CTX.restore();
  }
}

function drawRings() {
  for (const r of rings) {
    CTX.strokeStyle = `hsla(${r.hue},100%,65%,${r.life * 0.55})`;
    CTX.lineWidth = 2.5 * r.life;
    CTX.beginPath();
    CTX.arc(r.x, r.y, r.r, 0, Math.PI * 2);
    CTX.stroke();
  }
}

function drawTrail() {
  for (let i = 1; i < trail.length; i++) {
    const t = 1 - i / trail.length;
    CTX.fillStyle = `hsla(${(hue + i * 8) % 360},100%,60%,${t * 0.35})`;
    CTX.beginPath();
    CTX.arc(trail[i].x, trail[i].y, BALL_R * t * 0.65, 0, Math.PI * 2);
    CTX.fill();
  }
}

function drawParticles() {
  for (const p of particles) {
    CTX.fillStyle = `hsla(${p.hue % 360},100%,65%,${p.life * 0.75})`;
    CTX.beginPath();
    CTX.arc(p.x, p.y, p.r * p.life, 0, Math.PI * 2);
    CTX.fill();
  }
}

function drawBall() {
  const bx = ball.x, by = ball.y;

  // Outer glow
  const g = CTX.createRadialGradient(bx, by, 0, bx, by, BALL_R * 3.5);
  g.addColorStop(0, `hsla(${hue},100%,70%,0.35)`);
  g.addColorStop(1, `hsla(${hue},100%,70%,0)`);
  CTX.fillStyle = g;
  CTX.beginPath();
  CTX.arc(bx, by, BALL_R * 3.5, 0, Math.PI * 2);
  CTX.fill();

  // Body
  CTX.fillStyle = `hsl(${hue},100%,75%)`;
  CTX.shadowColor = `hsl(${hue},100%,60%)`;
  CTX.shadowBlur = 16;
  CTX.beginPath();
  CTX.arc(bx, by, BALL_R, 0, Math.PI * 2);
  CTX.fill();
  CTX.shadowBlur = 0;

  // Inner highlight
  CTX.fillStyle = `hsla(${hue},100%,92%,0.55)`;
  CTX.beginPath();
  CTX.arc(bx - 2.5, by - 2.5, BALL_R * 0.35, 0, Math.PI * 2);
  CTX.fill();
}

function drawHUD() {
  // Points top-left
  CTX.fillStyle = 'rgba(255,255,255,0.85)';
  CTX.font = 'bold 20px "Segoe UI",system-ui,sans-serif';
  CTX.textAlign = 'left';
  CTX.textBaseline = 'top';
  CTX.fillText(points, 14, 12);

  // Combo top-right
  if (combo > 1.4) {
    CTX.textAlign = 'right';
    CTX.font = 'bold 15px "Segoe UI",system-ui,sans-serif';
    CTX.fillStyle = `hsla(${(hue+60)%360},100%,70%,0.85)`;
    CTX.fillText('x' + combo.toFixed(1), W - 14, 14);
  }

  // Polarity arrow
  CTX.fillStyle = `hsla(${hue},70%,65%,0.5)`;
  CTX.font = '13px sans-serif';
  CTX.textAlign = 'right';
  CTX.textBaseline = 'top';
  CTX.fillText(polarity === 1 ? '\u25BC' : '\u25B2', W - 14, 34);
}

function drawFlash() {
  if (!flashMsg) return;
  const a = Math.min(1, flashTimer);
  CTX.save();
  CTX.textAlign = 'center';
  CTX.textBaseline = 'middle';
  CTX.font = 'bold 16px "Segoe UI",system-ui,sans-serif';
  CTX.fillStyle = `hsla(50,100%,75%,${a * 0.9})`;
  const oy = 20 * (1 - a);
  CTX.fillText(flashMsg, W * 0.5, H * 0.42 - oy);
  CTX.restore();
}

// --- START SCREEN ---
function drawStart() {
  const t = Date.now() * 0.001;

  // Floating particles
  for (let i = 0; i < 10; i++) {
    const px = W * 0.15 + W * 0.7 * ((Math.sin(t * 0.4 + i * 1.8) + 1) * 0.5);
    const py = H * 0.1  + H * 0.8 * ((Math.cos(t * 0.3 + i * 2.3) + 1) * 0.5);
    const sz = 1.5 + Math.sin(t * 1.2 + i) * 1;
    CTX.fillStyle = `hsla(${(t * 28 + i * 40) % 360},100%,65%,0.25)`;
    CTX.beginPath(); CTX.arc(px, py, sz, 0, Math.PI * 2); CTX.fill();
  }

  CTX.textAlign = 'center';
  CTX.textBaseline = 'middle';

  // Title
  const titleHue = (t * 30) % 360;
  CTX.fillStyle = `hsl(${titleHue},100%,70%)`;
  CTX.shadowColor = CTX.fillStyle;
  CTX.shadowBlur = 25;
  CTX.font = 'bold 36px "Segoe UI",system-ui,sans-serif';
  CTX.fillText('NEON BOUNCE', W * 0.5, H * 0.30);
  CTX.shadowBlur = 0;

  // Subtitle
  CTX.fillStyle = 'rgba(255,255,255,0.45)';
  CTX.font = '14px "Segoe UI",system-ui,sans-serif';
  CTX.fillText('Polarity Flip', W * 0.5, H * 0.37);

  // Tap prompt
  const pulse = 0.45 + 0.45 * Math.sin(t * 4);
  CTX.fillStyle = `rgba(255,255,255,${pulse})`;
  CTX.font = '17px "Segoe UI",system-ui,sans-serif';
  CTX.fillText('Tap to Start', W * 0.5, H * 0.53);

  // Instructions
  CTX.fillStyle = 'rgba(255,255,255,0.28)';
  CTX.font = '12px "Segoe UI",system-ui,sans-serif';
  CTX.fillText('Tap / Space to flip gravity', W * 0.5, H * 0.61);
  CTX.fillText('Land on pads \u2022 Avoid the void', W * 0.5, H * 0.65);

  // Best
  if (bestPoints > 0) {
    CTX.fillStyle = 'rgba(255,255,255,0.32)';
    CTX.font = '13px "Segoe UI",system-ui,sans-serif';
    CTX.fillText('Best: ' + bestPoints, W * 0.5, H * 0.73);
  }

  // Challenge
  if (challengeTarget > 0) {
    CTX.fillStyle = 'hsla(50,100%,65%,0.65)';
    CTX.font = 'bold 13px "Segoe UI",system-ui,sans-serif';
    CTX.fillText('Challenge: beat ' + challengeTarget + '!', W * 0.5, H * 0.79);
  }
}

// --- GAME OVER ---
function drawGameOver() {
  CTX.save();
  CTX.fillStyle = 'rgba(0,0,0,0.5)';
  CTX.fillRect(0, 0, W, H);

  CTX.textAlign = 'center';
  CTX.textBaseline = 'middle';

  // Title
  CTX.fillStyle = `hsl(${hue},75%,62%)`;
  CTX.shadowColor = CTX.fillStyle;
  CTX.shadowBlur = 18;
  CTX.font = 'bold 30px "Segoe UI",system-ui,sans-serif';
  CTX.fillText('GAME OVER', W * 0.5, H * 0.24);
  CTX.shadowBlur = 0;

  // Points big
  CTX.fillStyle = '#fff';
  CTX.font = 'bold 52px "Segoe UI",system-ui,sans-serif';
  CTX.fillText(points, W * 0.5, H * 0.36);

  CTX.fillStyle = 'rgba(255,255,255,0.45)';
  CTX.font = '12px "Segoe UI",system-ui,sans-serif';
  CTX.fillText('POINTS', W * 0.5, H * 0.41);

  // Landings + max combo
  CTX.fillStyle = 'rgba(255,255,255,0.65)';
  CTX.font = '16px "Segoe UI",system-ui,sans-serif';
  CTX.fillText(score + ' Landings  \u2022  Max x' + maxCombo.toFixed(1), W * 0.5, H * 0.48);

  // Best
  CTX.fillStyle = 'hsla(50,100%,65%,0.75)';
  CTX.font = 'bold 16px "Segoe UI",system-ui,sans-serif';
  CTX.fillText('Best: ' + bestPoints, W * 0.5, H * 0.54);

  // New best
  if (points >= bestPoints && points > 0) {
    const a = 0.55 + 0.4 * Math.sin(Date.now() * 0.005);
    CTX.fillStyle = `hsla(50,100%,70%,${a})`;
    CTX.font = 'bold 14px "Segoe UI",system-ui,sans-serif';
    CTX.fillText('\u2605 NEW BEST! \u2605', W * 0.5, H * 0.59);
  }

  // Challenge result
  if (challengeTarget > 0) {
    const beat = points >= challengeTarget;
    CTX.fillStyle = beat ? 'hsla(120,100%,65%,0.75)' : 'hsla(0,80%,60%,0.65)';
    CTX.font = 'bold 13px "Segoe UI",system-ui,sans-serif';
    CTX.fillText(
      beat ? 'Challenge ' + challengeTarget + ' BEATEN!' : 'Challenge ' + challengeTarget + ' \u2013 Try again!',
      W * 0.5, H * 0.64
    );
  }

  // Share button
  const sy = H * 0.71;
  const bw = 120, bh = 30, bx = W * 0.5 - bw * 0.5, by = sy - bh * 0.5;
  shareBtn = { x: bx, y: by, w: bw, h: bh };

  CTX.fillStyle = `hsla(${hue},65%,45%,0.8)`;
  rRect(CTX, bx, by, bw, bh, 15);
  CTX.fill();
  CTX.fillStyle = '#fff';
  CTX.font = 'bold 13px "Segoe UI",system-ui,sans-serif';
  CTX.fillText('\uD83D\uDD17 Share Score', W * 0.5, sy);

  // Flash message (Copied!)
  if (flashTimer > 0) {
    CTX.fillStyle = `rgba(255,255,255,${Math.min(1, flashTimer)})`;
    CTX.font = '12px "Segoe UI",system-ui,sans-serif';
    CTX.fillText(flashMsg, W * 0.5, sy + 22);
  }

  // Tap to retry
  const pulse = 0.35 + 0.5 * Math.sin(Date.now() * 0.004);
  CTX.fillStyle = `rgba(255,255,255,${pulse})`;
  CTX.font = '16px "Segoe UI",system-ui,sans-serif';
  CTX.fillText('Tap to Retry', W * 0.5, H * 0.83);

  CTX.restore();
}

function rRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.arcTo(x + w, y, x + w, y + r, r);
  ctx.lineTo(x + w, y + h - r);
  ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
  ctx.lineTo(x + r, y + h);
  ctx.arcTo(x, y + h, x, y + h - r, r);
  ctx.lineTo(x, y + r);
  ctx.arcTo(x, y, x + r, y, r);
  ctx.closePath();
}

// --- GAME LOOP ---
function loop(ts) {
  if (!lastTime) lastTime = ts;
  let dt = (ts - lastTime) * 0.001;
  lastTime = ts;
  if (dt > 0.1) dt = 0.016; // clamp

  update(dt);
  draw();
  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);

})();
</script>
</body>
</html>
